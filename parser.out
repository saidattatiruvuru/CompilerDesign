Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENTS
    NOT
    VOID

Grammar

Rule 0     S' -> prgm
Rule 1     prgm -> prgm stmt
Rule 2     prgm -> <empty>
Rule 3     stmt -> funcdef
Rule 4     stmt -> funccall SEMICOLON
Rule 5     stmt -> declare
Rule 6     stmt -> assign
Rule 7     stmt -> ifstmt
Rule 8     stmt -> whilestmt
Rule 9     stmt -> printstmt
Rule 10    stmt2 -> stmt2 stmtelt
Rule 11    stmt2 -> <empty>
Rule 12    stmtelt -> funccall SEMICOLON
Rule 13    stmtelt -> declare
Rule 14    stmtelt -> assign
Rule 15    stmtelt -> ifstmt
Rule 16    stmtelt -> whilestmt
Rule 17    stmtelt -> printstmt
Rule 18    stmtelt -> returnstmt
Rule 19    stmtelt -> continuestmt
Rule 20    stmtelt -> breakstmt
Rule 21    funcdef -> FUNCTION type IDENTIFIER funcdefy LCB nulltypeargsx RCB LFB stmt2 RFB fundefexit
Rule 22    funcdefy -> <empty>
Rule 23    fundefexit -> <empty>
Rule 24    nulltypeargsx -> nulltypeargs
Rule 25    nulltypeargs -> typeargs
Rule 26    nulltypeargs -> <empty>
Rule 27    typeargs -> typeargs typearg
Rule 28    typeargs -> typearg
Rule 29    typearg -> type typeargval
Rule 30    typeargval -> IDENTIFIER
Rule 31    expr -> expr OR andterm
Rule 32    expr -> andterm
Rule 33    andterm -> andterm AND equalterm
Rule 34    andterm -> equalterm
Rule 35    equalterm -> equalterm LOG relopterm
Rule 36    equalterm -> relopterm
Rule 37    relopterm -> relopterm RELOP arithterm
Rule 38    relopterm -> arithterm
Rule 39    arithterm -> arithterm ARITHOP multerm
Rule 40    arithterm -> multerm
Rule 41    multerm -> multerm MULTOP singleterm
Rule 42    multerm -> singleterm
Rule 43    singleterm -> IDENTIFIER
Rule 44    singleterm -> prefix INTNUM
Rule 45    singleterm -> prefix FLOATNUM
Rule 46    singleterm -> CHARACTER
Rule 47    singleterm -> LCB expr RCB
Rule 48    singleterm -> arrayid
Rule 49    prefix -> ARITHOP
Rule 50    prefix -> <empty>
Rule 51    assign -> lhs ASSIGN rhs SEMICOLON
Rule 52    lhs -> IDENTIFIER
Rule 53    lhs -> arrayid
Rule 54    rhs -> inputstmt
Rule 55    rhs -> expr
Rule 56    rhs -> funccall
Rule 57    inputstmt -> INPUT LCB type RCB
Rule 58    funccall -> IDENTIFIER LCB nullargs RCB
Rule 59    nullargs -> args
Rule 60    nullargs -> <empty>
Rule 61    args -> args SEPARATORS arg
Rule 62    args -> arg
Rule 63    arg -> IDENTIFIER
Rule 64    arg -> prefix INTNUM
Rule 65    arg -> prefix FLOATNUM
Rule 66    arg -> CHARACTER
Rule 67    arg -> arrayid
Rule 68    ifstmt -> IF LCB expr RCB LFB ifbegin stmt2 RFB ifend elsepart
Rule 69    ifbegin -> <empty>
Rule 70    ifend -> <empty>
Rule 71    elsepart -> ELSE LFB elsebegin stmt2 RFB elseend
Rule 72    elsebegin -> <empty>
Rule 73    elseend -> <empty>
Rule 74    elsepart -> <empty>
Rule 75    whilestmt -> WHILE LCB expr RCB LFB whilebegin stmt2 RFB whileend
Rule 76    whilebegin -> <empty>
Rule 77    whileend -> <empty>
Rule 78    printstmt -> PRINT LCB printables RCB SEMICOLON
Rule 79    printables -> printables SEPARATORS printable
Rule 80    printables -> printable
Rule 81    printable -> STRING
Rule 82    printable -> IDENTIFIER
Rule 83    printable -> arrayid
Rule 84    returnstmt -> RETURN returnelt SEMICOLON
Rule 85    returnelt -> expr
Rule 86    returnelt -> <empty>
Rule 87    breakstmt -> BREAK SEMICOLON
Rule 88    continuestmt -> CONTINUE SEMICOLON
Rule 89    declare -> type vars SEMICOLON
Rule 90    type -> FLOAT
Rule 91    type -> INT
Rule 92    type -> CHAR
Rule 93    vars -> var SEPARATORS vars
Rule 94    vars -> var
Rule 95    var -> IDENTIFIER val
Rule 96    var -> arrayvar
Rule 97    arrayvar -> arrayvar LSB INTNUM RSB
Rule 98    arrayvar -> IDENTIFIER LSB INTNUM RSB
Rule 99    arrayid -> arrayid1
Rule 100   arrayid1 -> arrayid1 LSB index RSB
Rule 101   arrayid1 -> IDENTIFIER LSB index RSB
Rule 102   index -> INTNUM
Rule 103   index -> IDENTIFIER
Rule 104   val -> ASSIGN expr
Rule 105   val -> ASSIGN inputstmt
Rule 106   val -> ASSIGN funccall
Rule 107   val -> <empty>

Terminals, with rules where they appear

AND                  : 33
ARITHOP              : 39 49
ASSIGN               : 51 104 105 106
BREAK                : 87
CHAR                 : 92
CHARACTER            : 46 66
COMMENTS             : 
CONTINUE             : 88
ELSE                 : 71
FLOAT                : 90
FLOATNUM             : 45 65
FUNCTION             : 21
IDENTIFIER           : 21 30 43 52 58 63 82 95 98 101 103
IF                   : 68
INPUT                : 57
INT                  : 91
INTNUM               : 44 64 97 98 102
LCB                  : 21 47 57 58 68 75 78
LFB                  : 21 68 71 75
LOG                  : 35
LSB                  : 97 98 100 101
MULTOP               : 41
NOT                  : 
OR                   : 31
PRINT                : 78
RCB                  : 21 47 57 58 68 75 78
RELOP                : 37
RETURN               : 84
RFB                  : 21 68 71 75
RSB                  : 97 98 100 101
SEMICOLON            : 4 12 51 78 84 87 88 89
SEPARATORS           : 61 79 93
STRING               : 81
VOID                 : 
WHILE                : 75
error                : 

Nonterminals, with rules where they appear

andterm              : 31 32 33
arg                  : 61 62
args                 : 59 61
arithterm            : 37 38 39
arrayid              : 48 53 67 83
arrayid1             : 99 100
arrayvar             : 96 97
assign               : 6 14
breakstmt            : 20
continuestmt         : 19
declare              : 5 13
elsebegin            : 71
elseend              : 71
elsepart             : 68
equalterm            : 33 34 35
expr                 : 31 47 55 68 75 85 104
funccall             : 4 12 56 106
funcdef              : 3
funcdefy             : 21
fundefexit           : 21
ifbegin              : 68
ifend                : 68
ifstmt               : 7 15
index                : 100 101
inputstmt            : 54 105
lhs                  : 51
multerm              : 39 40 41
nullargs             : 58
nulltypeargs         : 24
nulltypeargsx        : 21
prefix               : 44 45 64 65
prgm                 : 1 0
printable            : 79 80
printables           : 78 79
printstmt            : 9 17
relopterm            : 35 36 37
returnelt            : 84
returnstmt           : 18
rhs                  : 51
singleterm           : 41 42
stmt                 : 1
stmt2                : 10 21 68 71 75
stmtelt              : 10
type                 : 21 29 57 89
typearg              : 27 28
typeargs             : 25 27
typeargval           : 29
val                  : 95
var                  : 93 94
vars                 : 89 93
whilebegin           : 75
whileend             : 75
whilestmt            : 8 16

Parsing method: LALR

state 0

    (0) S' -> . prgm
    (1) prgm -> . prgm stmt
    (2) prgm -> .

    FUNCTION        reduce using rule 2 (prgm -> .)
    IDENTIFIER      reduce using rule 2 (prgm -> .)
    IF              reduce using rule 2 (prgm -> .)
    WHILE           reduce using rule 2 (prgm -> .)
    PRINT           reduce using rule 2 (prgm -> .)
    FLOAT           reduce using rule 2 (prgm -> .)
    INT             reduce using rule 2 (prgm -> .)
    CHAR            reduce using rule 2 (prgm -> .)
    $end            reduce using rule 2 (prgm -> .)

    prgm                           shift and go to state 1

state 1

    (0) S' -> prgm .
    (1) prgm -> prgm . stmt
    (3) stmt -> . funcdef
    (4) stmt -> . funccall SEMICOLON
    (5) stmt -> . declare
    (6) stmt -> . assign
    (7) stmt -> . ifstmt
    (8) stmt -> . whilestmt
    (9) stmt -> . printstmt
    (21) funcdef -> . FUNCTION type IDENTIFIER funcdefy LCB nulltypeargsx RCB LFB stmt2 RFB fundefexit
    (58) funccall -> . IDENTIFIER LCB nullargs RCB
    (89) declare -> . type vars SEMICOLON
    (51) assign -> . lhs ASSIGN rhs SEMICOLON
    (68) ifstmt -> . IF LCB expr RCB LFB ifbegin stmt2 RFB ifend elsepart
    (75) whilestmt -> . WHILE LCB expr RCB LFB whilebegin stmt2 RFB whileend
    (78) printstmt -> . PRINT LCB printables RCB SEMICOLON
    (90) type -> . FLOAT
    (91) type -> . INT
    (92) type -> . CHAR
    (52) lhs -> . IDENTIFIER
    (53) lhs -> . arrayid
    (99) arrayid -> . arrayid1
    (100) arrayid1 -> . arrayid1 LSB index RSB
    (101) arrayid1 -> . IDENTIFIER LSB index RSB

    FUNCTION        shift and go to state 10
    IDENTIFIER      shift and go to state 12
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    PRINT           shift and go to state 16
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    CHAR            shift and go to state 19

    stmt                           shift and go to state 2
    funcdef                        shift and go to state 3
    funccall                       shift and go to state 4
    declare                        shift and go to state 5
    assign                         shift and go to state 6
    ifstmt                         shift and go to state 7
    whilestmt                      shift and go to state 8
    printstmt                      shift and go to state 9
    type                           shift and go to state 11
    lhs                            shift and go to state 13
    arrayid                        shift and go to state 20
    arrayid1                       shift and go to state 21

state 2

    (1) prgm -> prgm stmt .

    FUNCTION        reduce using rule 1 (prgm -> prgm stmt .)
    IDENTIFIER      reduce using rule 1 (prgm -> prgm stmt .)
    IF              reduce using rule 1 (prgm -> prgm stmt .)
    WHILE           reduce using rule 1 (prgm -> prgm stmt .)
    PRINT           reduce using rule 1 (prgm -> prgm stmt .)
    FLOAT           reduce using rule 1 (prgm -> prgm stmt .)
    INT             reduce using rule 1 (prgm -> prgm stmt .)
    CHAR            reduce using rule 1 (prgm -> prgm stmt .)
    $end            reduce using rule 1 (prgm -> prgm stmt .)


state 3

    (3) stmt -> funcdef .

    FUNCTION        reduce using rule 3 (stmt -> funcdef .)
    IDENTIFIER      reduce using rule 3 (stmt -> funcdef .)
    IF              reduce using rule 3 (stmt -> funcdef .)
    WHILE           reduce using rule 3 (stmt -> funcdef .)
    PRINT           reduce using rule 3 (stmt -> funcdef .)
    FLOAT           reduce using rule 3 (stmt -> funcdef .)
    INT             reduce using rule 3 (stmt -> funcdef .)
    CHAR            reduce using rule 3 (stmt -> funcdef .)
    $end            reduce using rule 3 (stmt -> funcdef .)


state 4

    (4) stmt -> funccall . SEMICOLON

    SEMICOLON       shift and go to state 22


state 5

    (5) stmt -> declare .

    FUNCTION        reduce using rule 5 (stmt -> declare .)
    IDENTIFIER      reduce using rule 5 (stmt -> declare .)
    IF              reduce using rule 5 (stmt -> declare .)
    WHILE           reduce using rule 5 (stmt -> declare .)
    PRINT           reduce using rule 5 (stmt -> declare .)
    FLOAT           reduce using rule 5 (stmt -> declare .)
    INT             reduce using rule 5 (stmt -> declare .)
    CHAR            reduce using rule 5 (stmt -> declare .)
    $end            reduce using rule 5 (stmt -> declare .)


state 6

    (6) stmt -> assign .

    FUNCTION        reduce using rule 6 (stmt -> assign .)
    IDENTIFIER      reduce using rule 6 (stmt -> assign .)
    IF              reduce using rule 6 (stmt -> assign .)
    WHILE           reduce using rule 6 (stmt -> assign .)
    PRINT           reduce using rule 6 (stmt -> assign .)
    FLOAT           reduce using rule 6 (stmt -> assign .)
    INT             reduce using rule 6 (stmt -> assign .)
    CHAR            reduce using rule 6 (stmt -> assign .)
    $end            reduce using rule 6 (stmt -> assign .)


state 7

    (7) stmt -> ifstmt .

    FUNCTION        reduce using rule 7 (stmt -> ifstmt .)
    IDENTIFIER      reduce using rule 7 (stmt -> ifstmt .)
    IF              reduce using rule 7 (stmt -> ifstmt .)
    WHILE           reduce using rule 7 (stmt -> ifstmt .)
    PRINT           reduce using rule 7 (stmt -> ifstmt .)
    FLOAT           reduce using rule 7 (stmt -> ifstmt .)
    INT             reduce using rule 7 (stmt -> ifstmt .)
    CHAR            reduce using rule 7 (stmt -> ifstmt .)
    $end            reduce using rule 7 (stmt -> ifstmt .)


state 8

    (8) stmt -> whilestmt .

    FUNCTION        reduce using rule 8 (stmt -> whilestmt .)
    IDENTIFIER      reduce using rule 8 (stmt -> whilestmt .)
    IF              reduce using rule 8 (stmt -> whilestmt .)
    WHILE           reduce using rule 8 (stmt -> whilestmt .)
    PRINT           reduce using rule 8 (stmt -> whilestmt .)
    FLOAT           reduce using rule 8 (stmt -> whilestmt .)
    INT             reduce using rule 8 (stmt -> whilestmt .)
    CHAR            reduce using rule 8 (stmt -> whilestmt .)
    $end            reduce using rule 8 (stmt -> whilestmt .)


state 9

    (9) stmt -> printstmt .

    FUNCTION        reduce using rule 9 (stmt -> printstmt .)
    IDENTIFIER      reduce using rule 9 (stmt -> printstmt .)
    IF              reduce using rule 9 (stmt -> printstmt .)
    WHILE           reduce using rule 9 (stmt -> printstmt .)
    PRINT           reduce using rule 9 (stmt -> printstmt .)
    FLOAT           reduce using rule 9 (stmt -> printstmt .)
    INT             reduce using rule 9 (stmt -> printstmt .)
    CHAR            reduce using rule 9 (stmt -> printstmt .)
    $end            reduce using rule 9 (stmt -> printstmt .)


state 10

    (21) funcdef -> FUNCTION . type IDENTIFIER funcdefy LCB nulltypeargsx RCB LFB stmt2 RFB fundefexit
    (90) type -> . FLOAT
    (91) type -> . INT
    (92) type -> . CHAR

    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    CHAR            shift and go to state 19

    type                           shift and go to state 23

state 11

    (89) declare -> type . vars SEMICOLON
    (93) vars -> . var SEPARATORS vars
    (94) vars -> . var
    (95) var -> . IDENTIFIER val
    (96) var -> . arrayvar
    (97) arrayvar -> . arrayvar LSB INTNUM RSB
    (98) arrayvar -> . IDENTIFIER LSB INTNUM RSB

    IDENTIFIER      shift and go to state 26

    vars                           shift and go to state 24
    var                            shift and go to state 25
    arrayvar                       shift and go to state 27

state 12

    (58) funccall -> IDENTIFIER . LCB nullargs RCB
    (52) lhs -> IDENTIFIER .
    (101) arrayid1 -> IDENTIFIER . LSB index RSB

    LCB             shift and go to state 28
    ASSIGN          reduce using rule 52 (lhs -> IDENTIFIER .)
    LSB             shift and go to state 29


state 13

    (51) assign -> lhs . ASSIGN rhs SEMICOLON

    ASSIGN          shift and go to state 30


state 14

    (68) ifstmt -> IF . LCB expr RCB LFB ifbegin stmt2 RFB ifend elsepart

    LCB             shift and go to state 31


state 15

    (75) whilestmt -> WHILE . LCB expr RCB LFB whilebegin stmt2 RFB whileend

    LCB             shift and go to state 32


state 16

    (78) printstmt -> PRINT . LCB printables RCB SEMICOLON

    LCB             shift and go to state 33


state 17

    (90) type -> FLOAT .

    IDENTIFIER      reduce using rule 90 (type -> FLOAT .)
    RCB             reduce using rule 90 (type -> FLOAT .)


state 18

    (91) type -> INT .

    IDENTIFIER      reduce using rule 91 (type -> INT .)
    RCB             reduce using rule 91 (type -> INT .)


state 19

    (92) type -> CHAR .

    IDENTIFIER      reduce using rule 92 (type -> CHAR .)
    RCB             reduce using rule 92 (type -> CHAR .)


state 20

    (53) lhs -> arrayid .

    ASSIGN          reduce using rule 53 (lhs -> arrayid .)


state 21

    (99) arrayid -> arrayid1 .
    (100) arrayid1 -> arrayid1 . LSB index RSB

    ASSIGN          reduce using rule 99 (arrayid -> arrayid1 .)
    SEPARATORS      reduce using rule 99 (arrayid -> arrayid1 .)
    RCB             reduce using rule 99 (arrayid -> arrayid1 .)
    MULTOP          reduce using rule 99 (arrayid -> arrayid1 .)
    ARITHOP         reduce using rule 99 (arrayid -> arrayid1 .)
    RELOP           reduce using rule 99 (arrayid -> arrayid1 .)
    LOG             reduce using rule 99 (arrayid -> arrayid1 .)
    AND             reduce using rule 99 (arrayid -> arrayid1 .)
    OR              reduce using rule 99 (arrayid -> arrayid1 .)
    SEMICOLON       reduce using rule 99 (arrayid -> arrayid1 .)
    LSB             shift and go to state 34


state 22

    (4) stmt -> funccall SEMICOLON .

    FUNCTION        reduce using rule 4 (stmt -> funccall SEMICOLON .)
    IDENTIFIER      reduce using rule 4 (stmt -> funccall SEMICOLON .)
    IF              reduce using rule 4 (stmt -> funccall SEMICOLON .)
    WHILE           reduce using rule 4 (stmt -> funccall SEMICOLON .)
    PRINT           reduce using rule 4 (stmt -> funccall SEMICOLON .)
    FLOAT           reduce using rule 4 (stmt -> funccall SEMICOLON .)
    INT             reduce using rule 4 (stmt -> funccall SEMICOLON .)
    CHAR            reduce using rule 4 (stmt -> funccall SEMICOLON .)
    $end            reduce using rule 4 (stmt -> funccall SEMICOLON .)


state 23

    (21) funcdef -> FUNCTION type . IDENTIFIER funcdefy LCB nulltypeargsx RCB LFB stmt2 RFB fundefexit

    IDENTIFIER      shift and go to state 35


state 24

    (89) declare -> type vars . SEMICOLON

    SEMICOLON       shift and go to state 36


state 25

    (93) vars -> var . SEPARATORS vars
    (94) vars -> var .

    SEPARATORS      shift and go to state 37
    SEMICOLON       reduce using rule 94 (vars -> var .)


state 26

    (95) var -> IDENTIFIER . val
    (98) arrayvar -> IDENTIFIER . LSB INTNUM RSB
    (104) val -> . ASSIGN expr
    (105) val -> . ASSIGN inputstmt
    (106) val -> . ASSIGN funccall
    (107) val -> .

    LSB             shift and go to state 39
    ASSIGN          shift and go to state 40
    SEPARATORS      reduce using rule 107 (val -> .)
    SEMICOLON       reduce using rule 107 (val -> .)

    val                            shift and go to state 38

state 27

    (96) var -> arrayvar .
    (97) arrayvar -> arrayvar . LSB INTNUM RSB

    SEPARATORS      reduce using rule 96 (var -> arrayvar .)
    SEMICOLON       reduce using rule 96 (var -> arrayvar .)
    LSB             shift and go to state 41


state 28

    (58) funccall -> IDENTIFIER LCB . nullargs RCB
    (59) nullargs -> . args
    (60) nullargs -> .
    (61) args -> . args SEPARATORS arg
    (62) args -> . arg
    (63) arg -> . IDENTIFIER
    (64) arg -> . prefix INTNUM
    (65) arg -> . prefix FLOATNUM
    (66) arg -> . CHARACTER
    (67) arg -> . arrayid
    (49) prefix -> . ARITHOP
    (50) prefix -> .
    (99) arrayid -> . arrayid1
    (100) arrayid1 -> . arrayid1 LSB index RSB
    (101) arrayid1 -> . IDENTIFIER LSB index RSB

    RCB             reduce using rule 60 (nullargs -> .)
    IDENTIFIER      shift and go to state 42
    CHARACTER       shift and go to state 47
    ARITHOP         shift and go to state 49
    INTNUM          reduce using rule 50 (prefix -> .)
    FLOATNUM        reduce using rule 50 (prefix -> .)

    nullargs                       shift and go to state 43
    args                           shift and go to state 44
    arg                            shift and go to state 45
    prefix                         shift and go to state 46
    arrayid                        shift and go to state 48
    arrayid1                       shift and go to state 21

state 29

    (101) arrayid1 -> IDENTIFIER LSB . index RSB
    (102) index -> . INTNUM
    (103) index -> . IDENTIFIER

    INTNUM          shift and go to state 52
    IDENTIFIER      shift and go to state 50

    index                          shift and go to state 51

state 30

    (51) assign -> lhs ASSIGN . rhs SEMICOLON
    (54) rhs -> . inputstmt
    (55) rhs -> . expr
    (56) rhs -> . funccall
    (57) inputstmt -> . INPUT LCB type RCB
    (31) expr -> . expr OR andterm
    (32) expr -> . andterm
    (58) funccall -> . IDENTIFIER LCB nullargs RCB
    (33) andterm -> . andterm AND equalterm
    (34) andterm -> . equalterm
    (35) equalterm -> . equalterm LOG relopterm
    (36) equalterm -> . relopterm
    (37) relopterm -> . relopterm RELOP arithterm
    (38) relopterm -> . arithterm
    (39) arithterm -> . arithterm ARITHOP multerm
    (40) arithterm -> . multerm
    (41) multerm -> . multerm MULTOP singleterm
    (42) multerm -> . singleterm
    (43) singleterm -> . IDENTIFIER
    (44) singleterm -> . prefix INTNUM
    (45) singleterm -> . prefix FLOATNUM
    (46) singleterm -> . CHARACTER
    (47) singleterm -> . LCB expr RCB
    (48) singleterm -> . arrayid
    (49) prefix -> . ARITHOP
    (50) prefix -> .
    (99) arrayid -> . arrayid1
    (100) arrayid1 -> . arrayid1 LSB index RSB
    (101) arrayid1 -> . IDENTIFIER LSB index RSB

    INPUT           shift and go to state 57
    IDENTIFIER      shift and go to state 60
    CHARACTER       shift and go to state 67
    LCB             shift and go to state 58
    ARITHOP         shift and go to state 49
    INTNUM          reduce using rule 50 (prefix -> .)
    FLOATNUM        reduce using rule 50 (prefix -> .)

    rhs                            shift and go to state 53
    inputstmt                      shift and go to state 54
    expr                           shift and go to state 55
    funccall                       shift and go to state 56
    andterm                        shift and go to state 59
    equalterm                      shift and go to state 61
    relopterm                      shift and go to state 62
    arithterm                      shift and go to state 63
    multerm                        shift and go to state 64
    singleterm                     shift and go to state 65
    prefix                         shift and go to state 66
    arrayid                        shift and go to state 68
    arrayid1                       shift and go to state 21

state 31

    (68) ifstmt -> IF LCB . expr RCB LFB ifbegin stmt2 RFB ifend elsepart
    (31) expr -> . expr OR andterm
    (32) expr -> . andterm
    (33) andterm -> . andterm AND equalterm
    (34) andterm -> . equalterm
    (35) equalterm -> . equalterm LOG relopterm
    (36) equalterm -> . relopterm
    (37) relopterm -> . relopterm RELOP arithterm
    (38) relopterm -> . arithterm
    (39) arithterm -> . arithterm ARITHOP multerm
    (40) arithterm -> . multerm
    (41) multerm -> . multerm MULTOP singleterm
    (42) multerm -> . singleterm
    (43) singleterm -> . IDENTIFIER
    (44) singleterm -> . prefix INTNUM
    (45) singleterm -> . prefix FLOATNUM
    (46) singleterm -> . CHARACTER
    (47) singleterm -> . LCB expr RCB
    (48) singleterm -> . arrayid
    (49) prefix -> . ARITHOP
    (50) prefix -> .
    (99) arrayid -> . arrayid1
    (100) arrayid1 -> . arrayid1 LSB index RSB
    (101) arrayid1 -> . IDENTIFIER LSB index RSB

    IDENTIFIER      shift and go to state 70
    CHARACTER       shift and go to state 67
    LCB             shift and go to state 58
    ARITHOP         shift and go to state 49
    INTNUM          reduce using rule 50 (prefix -> .)
    FLOATNUM        reduce using rule 50 (prefix -> .)

    expr                           shift and go to state 69
    andterm                        shift and go to state 59
    equalterm                      shift and go to state 61
    relopterm                      shift and go to state 62
    arithterm                      shift and go to state 63
    multerm                        shift and go to state 64
    singleterm                     shift and go to state 65
    prefix                         shift and go to state 66
    arrayid                        shift and go to state 68
    arrayid1                       shift and go to state 21

state 32

    (75) whilestmt -> WHILE LCB . expr RCB LFB whilebegin stmt2 RFB whileend
    (31) expr -> . expr OR andterm
    (32) expr -> . andterm
    (33) andterm -> . andterm AND equalterm
    (34) andterm -> . equalterm
    (35) equalterm -> . equalterm LOG relopterm
    (36) equalterm -> . relopterm
    (37) relopterm -> . relopterm RELOP arithterm
    (38) relopterm -> . arithterm
    (39) arithterm -> . arithterm ARITHOP multerm
    (40) arithterm -> . multerm
    (41) multerm -> . multerm MULTOP singleterm
    (42) multerm -> . singleterm
    (43) singleterm -> . IDENTIFIER
    (44) singleterm -> . prefix INTNUM
    (45) singleterm -> . prefix FLOATNUM
    (46) singleterm -> . CHARACTER
    (47) singleterm -> . LCB expr RCB
    (48) singleterm -> . arrayid
    (49) prefix -> . ARITHOP
    (50) prefix -> .
    (99) arrayid -> . arrayid1
    (100) arrayid1 -> . arrayid1 LSB index RSB
    (101) arrayid1 -> . IDENTIFIER LSB index RSB

    IDENTIFIER      shift and go to state 70
    CHARACTER       shift and go to state 67
    LCB             shift and go to state 58
    ARITHOP         shift and go to state 49
    INTNUM          reduce using rule 50 (prefix -> .)
    FLOATNUM        reduce using rule 50 (prefix -> .)

    expr                           shift and go to state 71
    andterm                        shift and go to state 59
    equalterm                      shift and go to state 61
    relopterm                      shift and go to state 62
    arithterm                      shift and go to state 63
    multerm                        shift and go to state 64
    singleterm                     shift and go to state 65
    prefix                         shift and go to state 66
    arrayid                        shift and go to state 68
    arrayid1                       shift and go to state 21

state 33

    (78) printstmt -> PRINT LCB . printables RCB SEMICOLON
    (79) printables -> . printables SEPARATORS printable
    (80) printables -> . printable
    (81) printable -> . STRING
    (82) printable -> . IDENTIFIER
    (83) printable -> . arrayid
    (99) arrayid -> . arrayid1
    (100) arrayid1 -> . arrayid1 LSB index RSB
    (101) arrayid1 -> . IDENTIFIER LSB index RSB

    STRING          shift and go to state 74
    IDENTIFIER      shift and go to state 75

    printables                     shift and go to state 72
    printable                      shift and go to state 73
    arrayid                        shift and go to state 76
    arrayid1                       shift and go to state 21

state 34

    (100) arrayid1 -> arrayid1 LSB . index RSB
    (102) index -> . INTNUM
    (103) index -> . IDENTIFIER

    INTNUM          shift and go to state 52
    IDENTIFIER      shift and go to state 50

    index                          shift and go to state 77

state 35

    (21) funcdef -> FUNCTION type IDENTIFIER . funcdefy LCB nulltypeargsx RCB LFB stmt2 RFB fundefexit
    (22) funcdefy -> .

    LCB             reduce using rule 22 (funcdefy -> .)

    funcdefy                       shift and go to state 78

state 36

    (89) declare -> type vars SEMICOLON .

    FUNCTION        reduce using rule 89 (declare -> type vars SEMICOLON .)
    IDENTIFIER      reduce using rule 89 (declare -> type vars SEMICOLON .)
    IF              reduce using rule 89 (declare -> type vars SEMICOLON .)
    WHILE           reduce using rule 89 (declare -> type vars SEMICOLON .)
    PRINT           reduce using rule 89 (declare -> type vars SEMICOLON .)
    FLOAT           reduce using rule 89 (declare -> type vars SEMICOLON .)
    INT             reduce using rule 89 (declare -> type vars SEMICOLON .)
    CHAR            reduce using rule 89 (declare -> type vars SEMICOLON .)
    $end            reduce using rule 89 (declare -> type vars SEMICOLON .)
    RFB             reduce using rule 89 (declare -> type vars SEMICOLON .)
    RETURN          reduce using rule 89 (declare -> type vars SEMICOLON .)
    CONTINUE        reduce using rule 89 (declare -> type vars SEMICOLON .)
    BREAK           reduce using rule 89 (declare -> type vars SEMICOLON .)


state 37

    (93) vars -> var SEPARATORS . vars
    (93) vars -> . var SEPARATORS vars
    (94) vars -> . var
    (95) var -> . IDENTIFIER val
    (96) var -> . arrayvar
    (97) arrayvar -> . arrayvar LSB INTNUM RSB
    (98) arrayvar -> . IDENTIFIER LSB INTNUM RSB

    IDENTIFIER      shift and go to state 26

    var                            shift and go to state 25
    vars                           shift and go to state 79
    arrayvar                       shift and go to state 27

state 38

    (95) var -> IDENTIFIER val .

    SEPARATORS      reduce using rule 95 (var -> IDENTIFIER val .)
    SEMICOLON       reduce using rule 95 (var -> IDENTIFIER val .)


state 39

    (98) arrayvar -> IDENTIFIER LSB . INTNUM RSB

    INTNUM          shift and go to state 80


state 40

    (104) val -> ASSIGN . expr
    (105) val -> ASSIGN . inputstmt
    (106) val -> ASSIGN . funccall
    (31) expr -> . expr OR andterm
    (32) expr -> . andterm
    (57) inputstmt -> . INPUT LCB type RCB
    (58) funccall -> . IDENTIFIER LCB nullargs RCB
    (33) andterm -> . andterm AND equalterm
    (34) andterm -> . equalterm
    (35) equalterm -> . equalterm LOG relopterm
    (36) equalterm -> . relopterm
    (37) relopterm -> . relopterm RELOP arithterm
    (38) relopterm -> . arithterm
    (39) arithterm -> . arithterm ARITHOP multerm
    (40) arithterm -> . multerm
    (41) multerm -> . multerm MULTOP singleterm
    (42) multerm -> . singleterm
    (43) singleterm -> . IDENTIFIER
    (44) singleterm -> . prefix INTNUM
    (45) singleterm -> . prefix FLOATNUM
    (46) singleterm -> . CHARACTER
    (47) singleterm -> . LCB expr RCB
    (48) singleterm -> . arrayid
    (49) prefix -> . ARITHOP
    (50) prefix -> .
    (99) arrayid -> . arrayid1
    (100) arrayid1 -> . arrayid1 LSB index RSB
    (101) arrayid1 -> . IDENTIFIER LSB index RSB

    INPUT           shift and go to state 57
    IDENTIFIER      shift and go to state 60
    CHARACTER       shift and go to state 67
    LCB             shift and go to state 58
    ARITHOP         shift and go to state 49
    INTNUM          reduce using rule 50 (prefix -> .)
    FLOATNUM        reduce using rule 50 (prefix -> .)

    expr                           shift and go to state 81
    inputstmt                      shift and go to state 82
    funccall                       shift and go to state 83
    andterm                        shift and go to state 59
    equalterm                      shift and go to state 61
    relopterm                      shift and go to state 62
    arithterm                      shift and go to state 63
    multerm                        shift and go to state 64
    singleterm                     shift and go to state 65
    prefix                         shift and go to state 66
    arrayid                        shift and go to state 68
    arrayid1                       shift and go to state 21

state 41

    (97) arrayvar -> arrayvar LSB . INTNUM RSB

    INTNUM          shift and go to state 84


state 42

    (63) arg -> IDENTIFIER .
    (101) arrayid1 -> IDENTIFIER . LSB index RSB

    SEPARATORS      reduce using rule 63 (arg -> IDENTIFIER .)
    RCB             reduce using rule 63 (arg -> IDENTIFIER .)
    LSB             shift and go to state 29


state 43

    (58) funccall -> IDENTIFIER LCB nullargs . RCB

    RCB             shift and go to state 85


state 44

    (59) nullargs -> args .
    (61) args -> args . SEPARATORS arg

    RCB             reduce using rule 59 (nullargs -> args .)
    SEPARATORS      shift and go to state 86


state 45

    (62) args -> arg .

    SEPARATORS      reduce using rule 62 (args -> arg .)
    RCB             reduce using rule 62 (args -> arg .)


state 46

    (64) arg -> prefix . INTNUM
    (65) arg -> prefix . FLOATNUM

    INTNUM          shift and go to state 87
    FLOATNUM        shift and go to state 88


state 47

    (66) arg -> CHARACTER .

    SEPARATORS      reduce using rule 66 (arg -> CHARACTER .)
    RCB             reduce using rule 66 (arg -> CHARACTER .)


state 48

    (67) arg -> arrayid .

    SEPARATORS      reduce using rule 67 (arg -> arrayid .)
    RCB             reduce using rule 67 (arg -> arrayid .)


state 49

    (49) prefix -> ARITHOP .

    INTNUM          reduce using rule 49 (prefix -> ARITHOP .)
    FLOATNUM        reduce using rule 49 (prefix -> ARITHOP .)


state 50

    (103) index -> IDENTIFIER .

    RSB             reduce using rule 103 (index -> IDENTIFIER .)


state 51

    (101) arrayid1 -> IDENTIFIER LSB index . RSB

    RSB             shift and go to state 89


state 52

    (102) index -> INTNUM .

    RSB             reduce using rule 102 (index -> INTNUM .)


state 53

    (51) assign -> lhs ASSIGN rhs . SEMICOLON

    SEMICOLON       shift and go to state 90


state 54

    (54) rhs -> inputstmt .

    SEMICOLON       reduce using rule 54 (rhs -> inputstmt .)


state 55

    (55) rhs -> expr .
    (31) expr -> expr . OR andterm

    SEMICOLON       reduce using rule 55 (rhs -> expr .)
    OR              shift and go to state 91


state 56

    (56) rhs -> funccall .

    SEMICOLON       reduce using rule 56 (rhs -> funccall .)


state 57

    (57) inputstmt -> INPUT . LCB type RCB

    LCB             shift and go to state 92


state 58

    (47) singleterm -> LCB . expr RCB
    (31) expr -> . expr OR andterm
    (32) expr -> . andterm
    (33) andterm -> . andterm AND equalterm
    (34) andterm -> . equalterm
    (35) equalterm -> . equalterm LOG relopterm
    (36) equalterm -> . relopterm
    (37) relopterm -> . relopterm RELOP arithterm
    (38) relopterm -> . arithterm
    (39) arithterm -> . arithterm ARITHOP multerm
    (40) arithterm -> . multerm
    (41) multerm -> . multerm MULTOP singleterm
    (42) multerm -> . singleterm
    (43) singleterm -> . IDENTIFIER
    (44) singleterm -> . prefix INTNUM
    (45) singleterm -> . prefix FLOATNUM
    (46) singleterm -> . CHARACTER
    (47) singleterm -> . LCB expr RCB
    (48) singleterm -> . arrayid
    (49) prefix -> . ARITHOP
    (50) prefix -> .
    (99) arrayid -> . arrayid1
    (100) arrayid1 -> . arrayid1 LSB index RSB
    (101) arrayid1 -> . IDENTIFIER LSB index RSB

    IDENTIFIER      shift and go to state 70
    CHARACTER       shift and go to state 67
    LCB             shift and go to state 58
    ARITHOP         shift and go to state 49
    INTNUM          reduce using rule 50 (prefix -> .)
    FLOATNUM        reduce using rule 50 (prefix -> .)

    expr                           shift and go to state 93
    andterm                        shift and go to state 59
    equalterm                      shift and go to state 61
    relopterm                      shift and go to state 62
    arithterm                      shift and go to state 63
    multerm                        shift and go to state 64
    singleterm                     shift and go to state 65
    prefix                         shift and go to state 66
    arrayid                        shift and go to state 68
    arrayid1                       shift and go to state 21

state 59

    (32) expr -> andterm .
    (33) andterm -> andterm . AND equalterm

    OR              reduce using rule 32 (expr -> andterm .)
    SEMICOLON       reduce using rule 32 (expr -> andterm .)
    RCB             reduce using rule 32 (expr -> andterm .)
    SEPARATORS      reduce using rule 32 (expr -> andterm .)
    AND             shift and go to state 94


state 60

    (58) funccall -> IDENTIFIER . LCB nullargs RCB
    (43) singleterm -> IDENTIFIER .
    (101) arrayid1 -> IDENTIFIER . LSB index RSB

    LCB             shift and go to state 28
    MULTOP          reduce using rule 43 (singleterm -> IDENTIFIER .)
    ARITHOP         reduce using rule 43 (singleterm -> IDENTIFIER .)
    RELOP           reduce using rule 43 (singleterm -> IDENTIFIER .)
    LOG             reduce using rule 43 (singleterm -> IDENTIFIER .)
    AND             reduce using rule 43 (singleterm -> IDENTIFIER .)
    OR              reduce using rule 43 (singleterm -> IDENTIFIER .)
    SEMICOLON       reduce using rule 43 (singleterm -> IDENTIFIER .)
    SEPARATORS      reduce using rule 43 (singleterm -> IDENTIFIER .)
    LSB             shift and go to state 29


state 61

    (34) andterm -> equalterm .
    (35) equalterm -> equalterm . LOG relopterm

    AND             reduce using rule 34 (andterm -> equalterm .)
    OR              reduce using rule 34 (andterm -> equalterm .)
    SEMICOLON       reduce using rule 34 (andterm -> equalterm .)
    RCB             reduce using rule 34 (andterm -> equalterm .)
    SEPARATORS      reduce using rule 34 (andterm -> equalterm .)
    LOG             shift and go to state 95


state 62

    (36) equalterm -> relopterm .
    (37) relopterm -> relopterm . RELOP arithterm

    LOG             reduce using rule 36 (equalterm -> relopterm .)
    AND             reduce using rule 36 (equalterm -> relopterm .)
    OR              reduce using rule 36 (equalterm -> relopterm .)
    SEMICOLON       reduce using rule 36 (equalterm -> relopterm .)
    RCB             reduce using rule 36 (equalterm -> relopterm .)
    SEPARATORS      reduce using rule 36 (equalterm -> relopterm .)
    RELOP           shift and go to state 96


state 63

    (38) relopterm -> arithterm .
    (39) arithterm -> arithterm . ARITHOP multerm

    RELOP           reduce using rule 38 (relopterm -> arithterm .)
    LOG             reduce using rule 38 (relopterm -> arithterm .)
    AND             reduce using rule 38 (relopterm -> arithterm .)
    OR              reduce using rule 38 (relopterm -> arithterm .)
    SEMICOLON       reduce using rule 38 (relopterm -> arithterm .)
    RCB             reduce using rule 38 (relopterm -> arithterm .)
    SEPARATORS      reduce using rule 38 (relopterm -> arithterm .)
    ARITHOP         shift and go to state 97


state 64

    (40) arithterm -> multerm .
    (41) multerm -> multerm . MULTOP singleterm

    ARITHOP         reduce using rule 40 (arithterm -> multerm .)
    RELOP           reduce using rule 40 (arithterm -> multerm .)
    LOG             reduce using rule 40 (arithterm -> multerm .)
    AND             reduce using rule 40 (arithterm -> multerm .)
    OR              reduce using rule 40 (arithterm -> multerm .)
    SEMICOLON       reduce using rule 40 (arithterm -> multerm .)
    RCB             reduce using rule 40 (arithterm -> multerm .)
    SEPARATORS      reduce using rule 40 (arithterm -> multerm .)
    MULTOP          shift and go to state 98


state 65

    (42) multerm -> singleterm .

    MULTOP          reduce using rule 42 (multerm -> singleterm .)
    ARITHOP         reduce using rule 42 (multerm -> singleterm .)
    RELOP           reduce using rule 42 (multerm -> singleterm .)
    LOG             reduce using rule 42 (multerm -> singleterm .)
    AND             reduce using rule 42 (multerm -> singleterm .)
    OR              reduce using rule 42 (multerm -> singleterm .)
    SEMICOLON       reduce using rule 42 (multerm -> singleterm .)
    RCB             reduce using rule 42 (multerm -> singleterm .)
    SEPARATORS      reduce using rule 42 (multerm -> singleterm .)


state 66

    (44) singleterm -> prefix . INTNUM
    (45) singleterm -> prefix . FLOATNUM

    INTNUM          shift and go to state 99
    FLOATNUM        shift and go to state 100


state 67

    (46) singleterm -> CHARACTER .

    MULTOP          reduce using rule 46 (singleterm -> CHARACTER .)
    ARITHOP         reduce using rule 46 (singleterm -> CHARACTER .)
    RELOP           reduce using rule 46 (singleterm -> CHARACTER .)
    LOG             reduce using rule 46 (singleterm -> CHARACTER .)
    AND             reduce using rule 46 (singleterm -> CHARACTER .)
    OR              reduce using rule 46 (singleterm -> CHARACTER .)
    SEMICOLON       reduce using rule 46 (singleterm -> CHARACTER .)
    RCB             reduce using rule 46 (singleterm -> CHARACTER .)
    SEPARATORS      reduce using rule 46 (singleterm -> CHARACTER .)


state 68

    (48) singleterm -> arrayid .

    MULTOP          reduce using rule 48 (singleterm -> arrayid .)
    ARITHOP         reduce using rule 48 (singleterm -> arrayid .)
    RELOP           reduce using rule 48 (singleterm -> arrayid .)
    LOG             reduce using rule 48 (singleterm -> arrayid .)
    AND             reduce using rule 48 (singleterm -> arrayid .)
    OR              reduce using rule 48 (singleterm -> arrayid .)
    SEMICOLON       reduce using rule 48 (singleterm -> arrayid .)
    RCB             reduce using rule 48 (singleterm -> arrayid .)
    SEPARATORS      reduce using rule 48 (singleterm -> arrayid .)


state 69

    (68) ifstmt -> IF LCB expr . RCB LFB ifbegin stmt2 RFB ifend elsepart
    (31) expr -> expr . OR andterm

    RCB             shift and go to state 101
    OR              shift and go to state 91


state 70

    (43) singleterm -> IDENTIFIER .
    (101) arrayid1 -> IDENTIFIER . LSB index RSB

    MULTOP          reduce using rule 43 (singleterm -> IDENTIFIER .)
    ARITHOP         reduce using rule 43 (singleterm -> IDENTIFIER .)
    RELOP           reduce using rule 43 (singleterm -> IDENTIFIER .)
    LOG             reduce using rule 43 (singleterm -> IDENTIFIER .)
    AND             reduce using rule 43 (singleterm -> IDENTIFIER .)
    RCB             reduce using rule 43 (singleterm -> IDENTIFIER .)
    OR              reduce using rule 43 (singleterm -> IDENTIFIER .)
    SEMICOLON       reduce using rule 43 (singleterm -> IDENTIFIER .)
    SEPARATORS      reduce using rule 43 (singleterm -> IDENTIFIER .)
    LSB             shift and go to state 29


state 71

    (75) whilestmt -> WHILE LCB expr . RCB LFB whilebegin stmt2 RFB whileend
    (31) expr -> expr . OR andterm

    RCB             shift and go to state 102
    OR              shift and go to state 91


state 72

    (78) printstmt -> PRINT LCB printables . RCB SEMICOLON
    (79) printables -> printables . SEPARATORS printable

    RCB             shift and go to state 103
    SEPARATORS      shift and go to state 104


state 73

    (80) printables -> printable .

    RCB             reduce using rule 80 (printables -> printable .)
    SEPARATORS      reduce using rule 80 (printables -> printable .)


state 74

    (81) printable -> STRING .

    RCB             reduce using rule 81 (printable -> STRING .)
    SEPARATORS      reduce using rule 81 (printable -> STRING .)


state 75

    (82) printable -> IDENTIFIER .
    (101) arrayid1 -> IDENTIFIER . LSB index RSB

    RCB             reduce using rule 82 (printable -> IDENTIFIER .)
    SEPARATORS      reduce using rule 82 (printable -> IDENTIFIER .)
    LSB             shift and go to state 29


state 76

    (83) printable -> arrayid .

    RCB             reduce using rule 83 (printable -> arrayid .)
    SEPARATORS      reduce using rule 83 (printable -> arrayid .)


state 77

    (100) arrayid1 -> arrayid1 LSB index . RSB

    RSB             shift and go to state 105


state 78

    (21) funcdef -> FUNCTION type IDENTIFIER funcdefy . LCB nulltypeargsx RCB LFB stmt2 RFB fundefexit

    LCB             shift and go to state 106


state 79

    (93) vars -> var SEPARATORS vars .

    SEMICOLON       reduce using rule 93 (vars -> var SEPARATORS vars .)


state 80

    (98) arrayvar -> IDENTIFIER LSB INTNUM . RSB

    RSB             shift and go to state 107


state 81

    (104) val -> ASSIGN expr .
    (31) expr -> expr . OR andterm

    SEPARATORS      reduce using rule 104 (val -> ASSIGN expr .)
    SEMICOLON       reduce using rule 104 (val -> ASSIGN expr .)
    OR              shift and go to state 91


state 82

    (105) val -> ASSIGN inputstmt .

    SEPARATORS      reduce using rule 105 (val -> ASSIGN inputstmt .)
    SEMICOLON       reduce using rule 105 (val -> ASSIGN inputstmt .)


state 83

    (106) val -> ASSIGN funccall .

    SEPARATORS      reduce using rule 106 (val -> ASSIGN funccall .)
    SEMICOLON       reduce using rule 106 (val -> ASSIGN funccall .)


state 84

    (97) arrayvar -> arrayvar LSB INTNUM . RSB

    RSB             shift and go to state 108


state 85

    (58) funccall -> IDENTIFIER LCB nullargs RCB .

    SEMICOLON       reduce using rule 58 (funccall -> IDENTIFIER LCB nullargs RCB .)
    SEPARATORS      reduce using rule 58 (funccall -> IDENTIFIER LCB nullargs RCB .)


state 86

    (61) args -> args SEPARATORS . arg
    (63) arg -> . IDENTIFIER
    (64) arg -> . prefix INTNUM
    (65) arg -> . prefix FLOATNUM
    (66) arg -> . CHARACTER
    (67) arg -> . arrayid
    (49) prefix -> . ARITHOP
    (50) prefix -> .
    (99) arrayid -> . arrayid1
    (100) arrayid1 -> . arrayid1 LSB index RSB
    (101) arrayid1 -> . IDENTIFIER LSB index RSB

    IDENTIFIER      shift and go to state 42
    CHARACTER       shift and go to state 47
    ARITHOP         shift and go to state 49
    INTNUM          reduce using rule 50 (prefix -> .)
    FLOATNUM        reduce using rule 50 (prefix -> .)

    arg                            shift and go to state 109
    prefix                         shift and go to state 46
    arrayid                        shift and go to state 48
    arrayid1                       shift and go to state 21

state 87

    (64) arg -> prefix INTNUM .

    SEPARATORS      reduce using rule 64 (arg -> prefix INTNUM .)
    RCB             reduce using rule 64 (arg -> prefix INTNUM .)


state 88

    (65) arg -> prefix FLOATNUM .

    SEPARATORS      reduce using rule 65 (arg -> prefix FLOATNUM .)
    RCB             reduce using rule 65 (arg -> prefix FLOATNUM .)


state 89

    (101) arrayid1 -> IDENTIFIER LSB index RSB .

    LSB             reduce using rule 101 (arrayid1 -> IDENTIFIER LSB index RSB .)
    ASSIGN          reduce using rule 101 (arrayid1 -> IDENTIFIER LSB index RSB .)
    SEPARATORS      reduce using rule 101 (arrayid1 -> IDENTIFIER LSB index RSB .)
    RCB             reduce using rule 101 (arrayid1 -> IDENTIFIER LSB index RSB .)
    MULTOP          reduce using rule 101 (arrayid1 -> IDENTIFIER LSB index RSB .)
    ARITHOP         reduce using rule 101 (arrayid1 -> IDENTIFIER LSB index RSB .)
    RELOP           reduce using rule 101 (arrayid1 -> IDENTIFIER LSB index RSB .)
    LOG             reduce using rule 101 (arrayid1 -> IDENTIFIER LSB index RSB .)
    AND             reduce using rule 101 (arrayid1 -> IDENTIFIER LSB index RSB .)
    OR              reduce using rule 101 (arrayid1 -> IDENTIFIER LSB index RSB .)
    SEMICOLON       reduce using rule 101 (arrayid1 -> IDENTIFIER LSB index RSB .)


state 90

    (51) assign -> lhs ASSIGN rhs SEMICOLON .

    FUNCTION        reduce using rule 51 (assign -> lhs ASSIGN rhs SEMICOLON .)
    IDENTIFIER      reduce using rule 51 (assign -> lhs ASSIGN rhs SEMICOLON .)
    IF              reduce using rule 51 (assign -> lhs ASSIGN rhs SEMICOLON .)
    WHILE           reduce using rule 51 (assign -> lhs ASSIGN rhs SEMICOLON .)
    PRINT           reduce using rule 51 (assign -> lhs ASSIGN rhs SEMICOLON .)
    FLOAT           reduce using rule 51 (assign -> lhs ASSIGN rhs SEMICOLON .)
    INT             reduce using rule 51 (assign -> lhs ASSIGN rhs SEMICOLON .)
    CHAR            reduce using rule 51 (assign -> lhs ASSIGN rhs SEMICOLON .)
    $end            reduce using rule 51 (assign -> lhs ASSIGN rhs SEMICOLON .)
    RFB             reduce using rule 51 (assign -> lhs ASSIGN rhs SEMICOLON .)
    RETURN          reduce using rule 51 (assign -> lhs ASSIGN rhs SEMICOLON .)
    CONTINUE        reduce using rule 51 (assign -> lhs ASSIGN rhs SEMICOLON .)
    BREAK           reduce using rule 51 (assign -> lhs ASSIGN rhs SEMICOLON .)


state 91

    (31) expr -> expr OR . andterm
    (33) andterm -> . andterm AND equalterm
    (34) andterm -> . equalterm
    (35) equalterm -> . equalterm LOG relopterm
    (36) equalterm -> . relopterm
    (37) relopterm -> . relopterm RELOP arithterm
    (38) relopterm -> . arithterm
    (39) arithterm -> . arithterm ARITHOP multerm
    (40) arithterm -> . multerm
    (41) multerm -> . multerm MULTOP singleterm
    (42) multerm -> . singleterm
    (43) singleterm -> . IDENTIFIER
    (44) singleterm -> . prefix INTNUM
    (45) singleterm -> . prefix FLOATNUM
    (46) singleterm -> . CHARACTER
    (47) singleterm -> . LCB expr RCB
    (48) singleterm -> . arrayid
    (49) prefix -> . ARITHOP
    (50) prefix -> .
    (99) arrayid -> . arrayid1
    (100) arrayid1 -> . arrayid1 LSB index RSB
    (101) arrayid1 -> . IDENTIFIER LSB index RSB

    IDENTIFIER      shift and go to state 70
    CHARACTER       shift and go to state 67
    LCB             shift and go to state 58
    ARITHOP         shift and go to state 49
    INTNUM          reduce using rule 50 (prefix -> .)
    FLOATNUM        reduce using rule 50 (prefix -> .)

    andterm                        shift and go to state 110
    equalterm                      shift and go to state 61
    relopterm                      shift and go to state 62
    arithterm                      shift and go to state 63
    multerm                        shift and go to state 64
    singleterm                     shift and go to state 65
    prefix                         shift and go to state 66
    arrayid                        shift and go to state 68
    arrayid1                       shift and go to state 21

state 92

    (57) inputstmt -> INPUT LCB . type RCB
    (90) type -> . FLOAT
    (91) type -> . INT
    (92) type -> . CHAR

    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    CHAR            shift and go to state 19

    type                           shift and go to state 111

state 93

    (47) singleterm -> LCB expr . RCB
    (31) expr -> expr . OR andterm

    RCB             shift and go to state 112
    OR              shift and go to state 91


state 94

    (33) andterm -> andterm AND . equalterm
    (35) equalterm -> . equalterm LOG relopterm
    (36) equalterm -> . relopterm
    (37) relopterm -> . relopterm RELOP arithterm
    (38) relopterm -> . arithterm
    (39) arithterm -> . arithterm ARITHOP multerm
    (40) arithterm -> . multerm
    (41) multerm -> . multerm MULTOP singleterm
    (42) multerm -> . singleterm
    (43) singleterm -> . IDENTIFIER
    (44) singleterm -> . prefix INTNUM
    (45) singleterm -> . prefix FLOATNUM
    (46) singleterm -> . CHARACTER
    (47) singleterm -> . LCB expr RCB
    (48) singleterm -> . arrayid
    (49) prefix -> . ARITHOP
    (50) prefix -> .
    (99) arrayid -> . arrayid1
    (100) arrayid1 -> . arrayid1 LSB index RSB
    (101) arrayid1 -> . IDENTIFIER LSB index RSB

    IDENTIFIER      shift and go to state 70
    CHARACTER       shift and go to state 67
    LCB             shift and go to state 58
    ARITHOP         shift and go to state 49
    INTNUM          reduce using rule 50 (prefix -> .)
    FLOATNUM        reduce using rule 50 (prefix -> .)

    equalterm                      shift and go to state 113
    relopterm                      shift and go to state 62
    arithterm                      shift and go to state 63
    multerm                        shift and go to state 64
    singleterm                     shift and go to state 65
    prefix                         shift and go to state 66
    arrayid                        shift and go to state 68
    arrayid1                       shift and go to state 21

state 95

    (35) equalterm -> equalterm LOG . relopterm
    (37) relopterm -> . relopterm RELOP arithterm
    (38) relopterm -> . arithterm
    (39) arithterm -> . arithterm ARITHOP multerm
    (40) arithterm -> . multerm
    (41) multerm -> . multerm MULTOP singleterm
    (42) multerm -> . singleterm
    (43) singleterm -> . IDENTIFIER
    (44) singleterm -> . prefix INTNUM
    (45) singleterm -> . prefix FLOATNUM
    (46) singleterm -> . CHARACTER
    (47) singleterm -> . LCB expr RCB
    (48) singleterm -> . arrayid
    (49) prefix -> . ARITHOP
    (50) prefix -> .
    (99) arrayid -> . arrayid1
    (100) arrayid1 -> . arrayid1 LSB index RSB
    (101) arrayid1 -> . IDENTIFIER LSB index RSB

    IDENTIFIER      shift and go to state 70
    CHARACTER       shift and go to state 67
    LCB             shift and go to state 58
    ARITHOP         shift and go to state 49
    INTNUM          reduce using rule 50 (prefix -> .)
    FLOATNUM        reduce using rule 50 (prefix -> .)

    relopterm                      shift and go to state 114
    arithterm                      shift and go to state 63
    multerm                        shift and go to state 64
    singleterm                     shift and go to state 65
    prefix                         shift and go to state 66
    arrayid                        shift and go to state 68
    arrayid1                       shift and go to state 21

state 96

    (37) relopterm -> relopterm RELOP . arithterm
    (39) arithterm -> . arithterm ARITHOP multerm
    (40) arithterm -> . multerm
    (41) multerm -> . multerm MULTOP singleterm
    (42) multerm -> . singleterm
    (43) singleterm -> . IDENTIFIER
    (44) singleterm -> . prefix INTNUM
    (45) singleterm -> . prefix FLOATNUM
    (46) singleterm -> . CHARACTER
    (47) singleterm -> . LCB expr RCB
    (48) singleterm -> . arrayid
    (49) prefix -> . ARITHOP
    (50) prefix -> .
    (99) arrayid -> . arrayid1
    (100) arrayid1 -> . arrayid1 LSB index RSB
    (101) arrayid1 -> . IDENTIFIER LSB index RSB

    IDENTIFIER      shift and go to state 70
    CHARACTER       shift and go to state 67
    LCB             shift and go to state 58
    ARITHOP         shift and go to state 49
    INTNUM          reduce using rule 50 (prefix -> .)
    FLOATNUM        reduce using rule 50 (prefix -> .)

    arithterm                      shift and go to state 115
    multerm                        shift and go to state 64
    singleterm                     shift and go to state 65
    prefix                         shift and go to state 66
    arrayid                        shift and go to state 68
    arrayid1                       shift and go to state 21

state 97

    (39) arithterm -> arithterm ARITHOP . multerm
    (41) multerm -> . multerm MULTOP singleterm
    (42) multerm -> . singleterm
    (43) singleterm -> . IDENTIFIER
    (44) singleterm -> . prefix INTNUM
    (45) singleterm -> . prefix FLOATNUM
    (46) singleterm -> . CHARACTER
    (47) singleterm -> . LCB expr RCB
    (48) singleterm -> . arrayid
    (49) prefix -> . ARITHOP
    (50) prefix -> .
    (99) arrayid -> . arrayid1
    (100) arrayid1 -> . arrayid1 LSB index RSB
    (101) arrayid1 -> . IDENTIFIER LSB index RSB

    IDENTIFIER      shift and go to state 70
    CHARACTER       shift and go to state 67
    LCB             shift and go to state 58
    ARITHOP         shift and go to state 49
    INTNUM          reduce using rule 50 (prefix -> .)
    FLOATNUM        reduce using rule 50 (prefix -> .)

    multerm                        shift and go to state 116
    singleterm                     shift and go to state 65
    prefix                         shift and go to state 66
    arrayid                        shift and go to state 68
    arrayid1                       shift and go to state 21

state 98

    (41) multerm -> multerm MULTOP . singleterm
    (43) singleterm -> . IDENTIFIER
    (44) singleterm -> . prefix INTNUM
    (45) singleterm -> . prefix FLOATNUM
    (46) singleterm -> . CHARACTER
    (47) singleterm -> . LCB expr RCB
    (48) singleterm -> . arrayid
    (49) prefix -> . ARITHOP
    (50) prefix -> .
    (99) arrayid -> . arrayid1
    (100) arrayid1 -> . arrayid1 LSB index RSB
    (101) arrayid1 -> . IDENTIFIER LSB index RSB

    IDENTIFIER      shift and go to state 70
    CHARACTER       shift and go to state 67
    LCB             shift and go to state 58
    ARITHOP         shift and go to state 49
    INTNUM          reduce using rule 50 (prefix -> .)
    FLOATNUM        reduce using rule 50 (prefix -> .)

    singleterm                     shift and go to state 117
    prefix                         shift and go to state 66
    arrayid                        shift and go to state 68
    arrayid1                       shift and go to state 21

state 99

    (44) singleterm -> prefix INTNUM .

    MULTOP          reduce using rule 44 (singleterm -> prefix INTNUM .)
    ARITHOP         reduce using rule 44 (singleterm -> prefix INTNUM .)
    RELOP           reduce using rule 44 (singleterm -> prefix INTNUM .)
    LOG             reduce using rule 44 (singleterm -> prefix INTNUM .)
    AND             reduce using rule 44 (singleterm -> prefix INTNUM .)
    OR              reduce using rule 44 (singleterm -> prefix INTNUM .)
    SEMICOLON       reduce using rule 44 (singleterm -> prefix INTNUM .)
    RCB             reduce using rule 44 (singleterm -> prefix INTNUM .)
    SEPARATORS      reduce using rule 44 (singleterm -> prefix INTNUM .)


state 100

    (45) singleterm -> prefix FLOATNUM .

    MULTOP          reduce using rule 45 (singleterm -> prefix FLOATNUM .)
    ARITHOP         reduce using rule 45 (singleterm -> prefix FLOATNUM .)
    RELOP           reduce using rule 45 (singleterm -> prefix FLOATNUM .)
    LOG             reduce using rule 45 (singleterm -> prefix FLOATNUM .)
    AND             reduce using rule 45 (singleterm -> prefix FLOATNUM .)
    OR              reduce using rule 45 (singleterm -> prefix FLOATNUM .)
    SEMICOLON       reduce using rule 45 (singleterm -> prefix FLOATNUM .)
    RCB             reduce using rule 45 (singleterm -> prefix FLOATNUM .)
    SEPARATORS      reduce using rule 45 (singleterm -> prefix FLOATNUM .)


state 101

    (68) ifstmt -> IF LCB expr RCB . LFB ifbegin stmt2 RFB ifend elsepart

    LFB             shift and go to state 118


state 102

    (75) whilestmt -> WHILE LCB expr RCB . LFB whilebegin stmt2 RFB whileend

    LFB             shift and go to state 119


state 103

    (78) printstmt -> PRINT LCB printables RCB . SEMICOLON

    SEMICOLON       shift and go to state 120


state 104

    (79) printables -> printables SEPARATORS . printable
    (81) printable -> . STRING
    (82) printable -> . IDENTIFIER
    (83) printable -> . arrayid
    (99) arrayid -> . arrayid1
    (100) arrayid1 -> . arrayid1 LSB index RSB
    (101) arrayid1 -> . IDENTIFIER LSB index RSB

    STRING          shift and go to state 74
    IDENTIFIER      shift and go to state 75

    printable                      shift and go to state 121
    arrayid                        shift and go to state 76
    arrayid1                       shift and go to state 21

state 105

    (100) arrayid1 -> arrayid1 LSB index RSB .

    LSB             reduce using rule 100 (arrayid1 -> arrayid1 LSB index RSB .)
    ASSIGN          reduce using rule 100 (arrayid1 -> arrayid1 LSB index RSB .)
    SEPARATORS      reduce using rule 100 (arrayid1 -> arrayid1 LSB index RSB .)
    RCB             reduce using rule 100 (arrayid1 -> arrayid1 LSB index RSB .)
    MULTOP          reduce using rule 100 (arrayid1 -> arrayid1 LSB index RSB .)
    ARITHOP         reduce using rule 100 (arrayid1 -> arrayid1 LSB index RSB .)
    RELOP           reduce using rule 100 (arrayid1 -> arrayid1 LSB index RSB .)
    LOG             reduce using rule 100 (arrayid1 -> arrayid1 LSB index RSB .)
    AND             reduce using rule 100 (arrayid1 -> arrayid1 LSB index RSB .)
    OR              reduce using rule 100 (arrayid1 -> arrayid1 LSB index RSB .)
    SEMICOLON       reduce using rule 100 (arrayid1 -> arrayid1 LSB index RSB .)


state 106

    (21) funcdef -> FUNCTION type IDENTIFIER funcdefy LCB . nulltypeargsx RCB LFB stmt2 RFB fundefexit
    (24) nulltypeargsx -> . nulltypeargs
    (25) nulltypeargs -> . typeargs
    (26) nulltypeargs -> .
    (27) typeargs -> . typeargs typearg
    (28) typeargs -> . typearg
    (29) typearg -> . type typeargval
    (90) type -> . FLOAT
    (91) type -> . INT
    (92) type -> . CHAR

    RCB             reduce using rule 26 (nulltypeargs -> .)
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    CHAR            shift and go to state 19

    type                           shift and go to state 122
    nulltypeargsx                  shift and go to state 123
    nulltypeargs                   shift and go to state 124
    typeargs                       shift and go to state 125
    typearg                        shift and go to state 126

state 107

    (98) arrayvar -> IDENTIFIER LSB INTNUM RSB .

    LSB             reduce using rule 98 (arrayvar -> IDENTIFIER LSB INTNUM RSB .)
    SEPARATORS      reduce using rule 98 (arrayvar -> IDENTIFIER LSB INTNUM RSB .)
    SEMICOLON       reduce using rule 98 (arrayvar -> IDENTIFIER LSB INTNUM RSB .)


state 108

    (97) arrayvar -> arrayvar LSB INTNUM RSB .

    LSB             reduce using rule 97 (arrayvar -> arrayvar LSB INTNUM RSB .)
    SEPARATORS      reduce using rule 97 (arrayvar -> arrayvar LSB INTNUM RSB .)
    SEMICOLON       reduce using rule 97 (arrayvar -> arrayvar LSB INTNUM RSB .)


state 109

    (61) args -> args SEPARATORS arg .

    SEPARATORS      reduce using rule 61 (args -> args SEPARATORS arg .)
    RCB             reduce using rule 61 (args -> args SEPARATORS arg .)


state 110

    (31) expr -> expr OR andterm .
    (33) andterm -> andterm . AND equalterm

    OR              reduce using rule 31 (expr -> expr OR andterm .)
    SEMICOLON       reduce using rule 31 (expr -> expr OR andterm .)
    RCB             reduce using rule 31 (expr -> expr OR andterm .)
    SEPARATORS      reduce using rule 31 (expr -> expr OR andterm .)
    AND             shift and go to state 94


state 111

    (57) inputstmt -> INPUT LCB type . RCB

    RCB             shift and go to state 127


state 112

    (47) singleterm -> LCB expr RCB .

    MULTOP          reduce using rule 47 (singleterm -> LCB expr RCB .)
    ARITHOP         reduce using rule 47 (singleterm -> LCB expr RCB .)
    RELOP           reduce using rule 47 (singleterm -> LCB expr RCB .)
    LOG             reduce using rule 47 (singleterm -> LCB expr RCB .)
    AND             reduce using rule 47 (singleterm -> LCB expr RCB .)
    OR              reduce using rule 47 (singleterm -> LCB expr RCB .)
    SEMICOLON       reduce using rule 47 (singleterm -> LCB expr RCB .)
    RCB             reduce using rule 47 (singleterm -> LCB expr RCB .)
    SEPARATORS      reduce using rule 47 (singleterm -> LCB expr RCB .)


state 113

    (33) andterm -> andterm AND equalterm .
    (35) equalterm -> equalterm . LOG relopterm

    AND             reduce using rule 33 (andterm -> andterm AND equalterm .)
    OR              reduce using rule 33 (andterm -> andterm AND equalterm .)
    SEMICOLON       reduce using rule 33 (andterm -> andterm AND equalterm .)
    RCB             reduce using rule 33 (andterm -> andterm AND equalterm .)
    SEPARATORS      reduce using rule 33 (andterm -> andterm AND equalterm .)
    LOG             shift and go to state 95


state 114

    (35) equalterm -> equalterm LOG relopterm .
    (37) relopterm -> relopterm . RELOP arithterm

    LOG             reduce using rule 35 (equalterm -> equalterm LOG relopterm .)
    AND             reduce using rule 35 (equalterm -> equalterm LOG relopterm .)
    OR              reduce using rule 35 (equalterm -> equalterm LOG relopterm .)
    SEMICOLON       reduce using rule 35 (equalterm -> equalterm LOG relopterm .)
    RCB             reduce using rule 35 (equalterm -> equalterm LOG relopterm .)
    SEPARATORS      reduce using rule 35 (equalterm -> equalterm LOG relopterm .)
    RELOP           shift and go to state 96


state 115

    (37) relopterm -> relopterm RELOP arithterm .
    (39) arithterm -> arithterm . ARITHOP multerm

    RELOP           reduce using rule 37 (relopterm -> relopterm RELOP arithterm .)
    LOG             reduce using rule 37 (relopterm -> relopterm RELOP arithterm .)
    AND             reduce using rule 37 (relopterm -> relopterm RELOP arithterm .)
    OR              reduce using rule 37 (relopterm -> relopterm RELOP arithterm .)
    SEMICOLON       reduce using rule 37 (relopterm -> relopterm RELOP arithterm .)
    RCB             reduce using rule 37 (relopterm -> relopterm RELOP arithterm .)
    SEPARATORS      reduce using rule 37 (relopterm -> relopterm RELOP arithterm .)
    ARITHOP         shift and go to state 97


state 116

    (39) arithterm -> arithterm ARITHOP multerm .
    (41) multerm -> multerm . MULTOP singleterm

    ARITHOP         reduce using rule 39 (arithterm -> arithterm ARITHOP multerm .)
    RELOP           reduce using rule 39 (arithterm -> arithterm ARITHOP multerm .)
    LOG             reduce using rule 39 (arithterm -> arithterm ARITHOP multerm .)
    AND             reduce using rule 39 (arithterm -> arithterm ARITHOP multerm .)
    OR              reduce using rule 39 (arithterm -> arithterm ARITHOP multerm .)
    SEMICOLON       reduce using rule 39 (arithterm -> arithterm ARITHOP multerm .)
    RCB             reduce using rule 39 (arithterm -> arithterm ARITHOP multerm .)
    SEPARATORS      reduce using rule 39 (arithterm -> arithterm ARITHOP multerm .)
    MULTOP          shift and go to state 98


state 117

    (41) multerm -> multerm MULTOP singleterm .

    MULTOP          reduce using rule 41 (multerm -> multerm MULTOP singleterm .)
    ARITHOP         reduce using rule 41 (multerm -> multerm MULTOP singleterm .)
    RELOP           reduce using rule 41 (multerm -> multerm MULTOP singleterm .)
    LOG             reduce using rule 41 (multerm -> multerm MULTOP singleterm .)
    AND             reduce using rule 41 (multerm -> multerm MULTOP singleterm .)
    OR              reduce using rule 41 (multerm -> multerm MULTOP singleterm .)
    SEMICOLON       reduce using rule 41 (multerm -> multerm MULTOP singleterm .)
    RCB             reduce using rule 41 (multerm -> multerm MULTOP singleterm .)
    SEPARATORS      reduce using rule 41 (multerm -> multerm MULTOP singleterm .)


state 118

    (68) ifstmt -> IF LCB expr RCB LFB . ifbegin stmt2 RFB ifend elsepart
    (69) ifbegin -> .

    RFB             reduce using rule 69 (ifbegin -> .)
    IDENTIFIER      reduce using rule 69 (ifbegin -> .)
    IF              reduce using rule 69 (ifbegin -> .)
    WHILE           reduce using rule 69 (ifbegin -> .)
    PRINT           reduce using rule 69 (ifbegin -> .)
    RETURN          reduce using rule 69 (ifbegin -> .)
    CONTINUE        reduce using rule 69 (ifbegin -> .)
    BREAK           reduce using rule 69 (ifbegin -> .)
    FLOAT           reduce using rule 69 (ifbegin -> .)
    INT             reduce using rule 69 (ifbegin -> .)
    CHAR            reduce using rule 69 (ifbegin -> .)

    ifbegin                        shift and go to state 128

state 119

    (75) whilestmt -> WHILE LCB expr RCB LFB . whilebegin stmt2 RFB whileend
    (76) whilebegin -> .

    RFB             reduce using rule 76 (whilebegin -> .)
    IDENTIFIER      reduce using rule 76 (whilebegin -> .)
    IF              reduce using rule 76 (whilebegin -> .)
    WHILE           reduce using rule 76 (whilebegin -> .)
    PRINT           reduce using rule 76 (whilebegin -> .)
    RETURN          reduce using rule 76 (whilebegin -> .)
    CONTINUE        reduce using rule 76 (whilebegin -> .)
    BREAK           reduce using rule 76 (whilebegin -> .)
    FLOAT           reduce using rule 76 (whilebegin -> .)
    INT             reduce using rule 76 (whilebegin -> .)
    CHAR            reduce using rule 76 (whilebegin -> .)

    whilebegin                     shift and go to state 129

state 120

    (78) printstmt -> PRINT LCB printables RCB SEMICOLON .

    FUNCTION        reduce using rule 78 (printstmt -> PRINT LCB printables RCB SEMICOLON .)
    IDENTIFIER      reduce using rule 78 (printstmt -> PRINT LCB printables RCB SEMICOLON .)
    IF              reduce using rule 78 (printstmt -> PRINT LCB printables RCB SEMICOLON .)
    WHILE           reduce using rule 78 (printstmt -> PRINT LCB printables RCB SEMICOLON .)
    PRINT           reduce using rule 78 (printstmt -> PRINT LCB printables RCB SEMICOLON .)
    FLOAT           reduce using rule 78 (printstmt -> PRINT LCB printables RCB SEMICOLON .)
    INT             reduce using rule 78 (printstmt -> PRINT LCB printables RCB SEMICOLON .)
    CHAR            reduce using rule 78 (printstmt -> PRINT LCB printables RCB SEMICOLON .)
    $end            reduce using rule 78 (printstmt -> PRINT LCB printables RCB SEMICOLON .)
    RFB             reduce using rule 78 (printstmt -> PRINT LCB printables RCB SEMICOLON .)
    RETURN          reduce using rule 78 (printstmt -> PRINT LCB printables RCB SEMICOLON .)
    CONTINUE        reduce using rule 78 (printstmt -> PRINT LCB printables RCB SEMICOLON .)
    BREAK           reduce using rule 78 (printstmt -> PRINT LCB printables RCB SEMICOLON .)


state 121

    (79) printables -> printables SEPARATORS printable .

    RCB             reduce using rule 79 (printables -> printables SEPARATORS printable .)
    SEPARATORS      reduce using rule 79 (printables -> printables SEPARATORS printable .)


state 122

    (29) typearg -> type . typeargval
    (30) typeargval -> . IDENTIFIER

    IDENTIFIER      shift and go to state 131

    typeargval                     shift and go to state 130

state 123

    (21) funcdef -> FUNCTION type IDENTIFIER funcdefy LCB nulltypeargsx . RCB LFB stmt2 RFB fundefexit

    RCB             shift and go to state 132


state 124

    (24) nulltypeargsx -> nulltypeargs .

    RCB             reduce using rule 24 (nulltypeargsx -> nulltypeargs .)


state 125

    (25) nulltypeargs -> typeargs .
    (27) typeargs -> typeargs . typearg
    (29) typearg -> . type typeargval
    (90) type -> . FLOAT
    (91) type -> . INT
    (92) type -> . CHAR

    RCB             reduce using rule 25 (nulltypeargs -> typeargs .)
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    CHAR            shift and go to state 19

    typearg                        shift and go to state 133
    type                           shift and go to state 122

state 126

    (28) typeargs -> typearg .

    FLOAT           reduce using rule 28 (typeargs -> typearg .)
    INT             reduce using rule 28 (typeargs -> typearg .)
    CHAR            reduce using rule 28 (typeargs -> typearg .)
    RCB             reduce using rule 28 (typeargs -> typearg .)


state 127

    (57) inputstmt -> INPUT LCB type RCB .

    SEMICOLON       reduce using rule 57 (inputstmt -> INPUT LCB type RCB .)
    SEPARATORS      reduce using rule 57 (inputstmt -> INPUT LCB type RCB .)


state 128

    (68) ifstmt -> IF LCB expr RCB LFB ifbegin . stmt2 RFB ifend elsepart
    (10) stmt2 -> . stmt2 stmtelt
    (11) stmt2 -> .

    RFB             reduce using rule 11 (stmt2 -> .)
    IDENTIFIER      reduce using rule 11 (stmt2 -> .)
    IF              reduce using rule 11 (stmt2 -> .)
    WHILE           reduce using rule 11 (stmt2 -> .)
    PRINT           reduce using rule 11 (stmt2 -> .)
    RETURN          reduce using rule 11 (stmt2 -> .)
    CONTINUE        reduce using rule 11 (stmt2 -> .)
    BREAK           reduce using rule 11 (stmt2 -> .)
    FLOAT           reduce using rule 11 (stmt2 -> .)
    INT             reduce using rule 11 (stmt2 -> .)
    CHAR            reduce using rule 11 (stmt2 -> .)

    stmt2                          shift and go to state 134

state 129

    (75) whilestmt -> WHILE LCB expr RCB LFB whilebegin . stmt2 RFB whileend
    (10) stmt2 -> . stmt2 stmtelt
    (11) stmt2 -> .

    RFB             reduce using rule 11 (stmt2 -> .)
    IDENTIFIER      reduce using rule 11 (stmt2 -> .)
    IF              reduce using rule 11 (stmt2 -> .)
    WHILE           reduce using rule 11 (stmt2 -> .)
    PRINT           reduce using rule 11 (stmt2 -> .)
    RETURN          reduce using rule 11 (stmt2 -> .)
    CONTINUE        reduce using rule 11 (stmt2 -> .)
    BREAK           reduce using rule 11 (stmt2 -> .)
    FLOAT           reduce using rule 11 (stmt2 -> .)
    INT             reduce using rule 11 (stmt2 -> .)
    CHAR            reduce using rule 11 (stmt2 -> .)

    stmt2                          shift and go to state 135

state 130

    (29) typearg -> type typeargval .

    FLOAT           reduce using rule 29 (typearg -> type typeargval .)
    INT             reduce using rule 29 (typearg -> type typeargval .)
    CHAR            reduce using rule 29 (typearg -> type typeargval .)
    RCB             reduce using rule 29 (typearg -> type typeargval .)


state 131

    (30) typeargval -> IDENTIFIER .

    FLOAT           reduce using rule 30 (typeargval -> IDENTIFIER .)
    INT             reduce using rule 30 (typeargval -> IDENTIFIER .)
    CHAR            reduce using rule 30 (typeargval -> IDENTIFIER .)
    RCB             reduce using rule 30 (typeargval -> IDENTIFIER .)


state 132

    (21) funcdef -> FUNCTION type IDENTIFIER funcdefy LCB nulltypeargsx RCB . LFB stmt2 RFB fundefexit

    LFB             shift and go to state 136


state 133

    (27) typeargs -> typeargs typearg .

    FLOAT           reduce using rule 27 (typeargs -> typeargs typearg .)
    INT             reduce using rule 27 (typeargs -> typeargs typearg .)
    CHAR            reduce using rule 27 (typeargs -> typeargs typearg .)
    RCB             reduce using rule 27 (typeargs -> typeargs typearg .)


state 134

    (68) ifstmt -> IF LCB expr RCB LFB ifbegin stmt2 . RFB ifend elsepart
    (10) stmt2 -> stmt2 . stmtelt
    (12) stmtelt -> . funccall SEMICOLON
    (13) stmtelt -> . declare
    (14) stmtelt -> . assign
    (15) stmtelt -> . ifstmt
    (16) stmtelt -> . whilestmt
    (17) stmtelt -> . printstmt
    (18) stmtelt -> . returnstmt
    (19) stmtelt -> . continuestmt
    (20) stmtelt -> . breakstmt
    (58) funccall -> . IDENTIFIER LCB nullargs RCB
    (89) declare -> . type vars SEMICOLON
    (51) assign -> . lhs ASSIGN rhs SEMICOLON
    (68) ifstmt -> . IF LCB expr RCB LFB ifbegin stmt2 RFB ifend elsepart
    (75) whilestmt -> . WHILE LCB expr RCB LFB whilebegin stmt2 RFB whileend
    (78) printstmt -> . PRINT LCB printables RCB SEMICOLON
    (84) returnstmt -> . RETURN returnelt SEMICOLON
    (88) continuestmt -> . CONTINUE SEMICOLON
    (87) breakstmt -> . BREAK SEMICOLON
    (90) type -> . FLOAT
    (91) type -> . INT
    (92) type -> . CHAR
    (52) lhs -> . IDENTIFIER
    (53) lhs -> . arrayid
    (99) arrayid -> . arrayid1
    (100) arrayid1 -> . arrayid1 LSB index RSB
    (101) arrayid1 -> . IDENTIFIER LSB index RSB

    RFB             shift and go to state 137
    IDENTIFIER      shift and go to state 12
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    PRINT           shift and go to state 16
    RETURN          shift and go to state 148
    CONTINUE        shift and go to state 149
    BREAK           shift and go to state 150
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    CHAR            shift and go to state 19

    stmtelt                        shift and go to state 138
    funccall                       shift and go to state 139
    declare                        shift and go to state 140
    assign                         shift and go to state 141
    ifstmt                         shift and go to state 142
    whilestmt                      shift and go to state 143
    printstmt                      shift and go to state 144
    returnstmt                     shift and go to state 145
    continuestmt                   shift and go to state 146
    breakstmt                      shift and go to state 147
    type                           shift and go to state 11
    lhs                            shift and go to state 13
    arrayid                        shift and go to state 20
    arrayid1                       shift and go to state 21

state 135

    (75) whilestmt -> WHILE LCB expr RCB LFB whilebegin stmt2 . RFB whileend
    (10) stmt2 -> stmt2 . stmtelt
    (12) stmtelt -> . funccall SEMICOLON
    (13) stmtelt -> . declare
    (14) stmtelt -> . assign
    (15) stmtelt -> . ifstmt
    (16) stmtelt -> . whilestmt
    (17) stmtelt -> . printstmt
    (18) stmtelt -> . returnstmt
    (19) stmtelt -> . continuestmt
    (20) stmtelt -> . breakstmt
    (58) funccall -> . IDENTIFIER LCB nullargs RCB
    (89) declare -> . type vars SEMICOLON
    (51) assign -> . lhs ASSIGN rhs SEMICOLON
    (68) ifstmt -> . IF LCB expr RCB LFB ifbegin stmt2 RFB ifend elsepart
    (75) whilestmt -> . WHILE LCB expr RCB LFB whilebegin stmt2 RFB whileend
    (78) printstmt -> . PRINT LCB printables RCB SEMICOLON
    (84) returnstmt -> . RETURN returnelt SEMICOLON
    (88) continuestmt -> . CONTINUE SEMICOLON
    (87) breakstmt -> . BREAK SEMICOLON
    (90) type -> . FLOAT
    (91) type -> . INT
    (92) type -> . CHAR
    (52) lhs -> . IDENTIFIER
    (53) lhs -> . arrayid
    (99) arrayid -> . arrayid1
    (100) arrayid1 -> . arrayid1 LSB index RSB
    (101) arrayid1 -> . IDENTIFIER LSB index RSB

    RFB             shift and go to state 151
    IDENTIFIER      shift and go to state 12
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    PRINT           shift and go to state 16
    RETURN          shift and go to state 148
    CONTINUE        shift and go to state 149
    BREAK           shift and go to state 150
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    CHAR            shift and go to state 19

    stmtelt                        shift and go to state 138
    funccall                       shift and go to state 139
    declare                        shift and go to state 140
    assign                         shift and go to state 141
    ifstmt                         shift and go to state 142
    whilestmt                      shift and go to state 143
    printstmt                      shift and go to state 144
    returnstmt                     shift and go to state 145
    continuestmt                   shift and go to state 146
    breakstmt                      shift and go to state 147
    type                           shift and go to state 11
    lhs                            shift and go to state 13
    arrayid                        shift and go to state 20
    arrayid1                       shift and go to state 21

state 136

    (21) funcdef -> FUNCTION type IDENTIFIER funcdefy LCB nulltypeargsx RCB LFB . stmt2 RFB fundefexit
    (10) stmt2 -> . stmt2 stmtelt
    (11) stmt2 -> .

    RFB             reduce using rule 11 (stmt2 -> .)
    IDENTIFIER      reduce using rule 11 (stmt2 -> .)
    IF              reduce using rule 11 (stmt2 -> .)
    WHILE           reduce using rule 11 (stmt2 -> .)
    PRINT           reduce using rule 11 (stmt2 -> .)
    RETURN          reduce using rule 11 (stmt2 -> .)
    CONTINUE        reduce using rule 11 (stmt2 -> .)
    BREAK           reduce using rule 11 (stmt2 -> .)
    FLOAT           reduce using rule 11 (stmt2 -> .)
    INT             reduce using rule 11 (stmt2 -> .)
    CHAR            reduce using rule 11 (stmt2 -> .)

    stmt2                          shift and go to state 152

state 137

    (68) ifstmt -> IF LCB expr RCB LFB ifbegin stmt2 RFB . ifend elsepart
    (70) ifend -> .

    ELSE            reduce using rule 70 (ifend -> .)
    FUNCTION        reduce using rule 70 (ifend -> .)
    IDENTIFIER      reduce using rule 70 (ifend -> .)
    IF              reduce using rule 70 (ifend -> .)
    WHILE           reduce using rule 70 (ifend -> .)
    PRINT           reduce using rule 70 (ifend -> .)
    FLOAT           reduce using rule 70 (ifend -> .)
    INT             reduce using rule 70 (ifend -> .)
    CHAR            reduce using rule 70 (ifend -> .)
    $end            reduce using rule 70 (ifend -> .)
    RFB             reduce using rule 70 (ifend -> .)
    RETURN          reduce using rule 70 (ifend -> .)
    CONTINUE        reduce using rule 70 (ifend -> .)
    BREAK           reduce using rule 70 (ifend -> .)

    ifend                          shift and go to state 153

state 138

    (10) stmt2 -> stmt2 stmtelt .

    RFB             reduce using rule 10 (stmt2 -> stmt2 stmtelt .)
    IDENTIFIER      reduce using rule 10 (stmt2 -> stmt2 stmtelt .)
    IF              reduce using rule 10 (stmt2 -> stmt2 stmtelt .)
    WHILE           reduce using rule 10 (stmt2 -> stmt2 stmtelt .)
    PRINT           reduce using rule 10 (stmt2 -> stmt2 stmtelt .)
    RETURN          reduce using rule 10 (stmt2 -> stmt2 stmtelt .)
    CONTINUE        reduce using rule 10 (stmt2 -> stmt2 stmtelt .)
    BREAK           reduce using rule 10 (stmt2 -> stmt2 stmtelt .)
    FLOAT           reduce using rule 10 (stmt2 -> stmt2 stmtelt .)
    INT             reduce using rule 10 (stmt2 -> stmt2 stmtelt .)
    CHAR            reduce using rule 10 (stmt2 -> stmt2 stmtelt .)


state 139

    (12) stmtelt -> funccall . SEMICOLON

    SEMICOLON       shift and go to state 154


state 140

    (13) stmtelt -> declare .

    RFB             reduce using rule 13 (stmtelt -> declare .)
    IDENTIFIER      reduce using rule 13 (stmtelt -> declare .)
    IF              reduce using rule 13 (stmtelt -> declare .)
    WHILE           reduce using rule 13 (stmtelt -> declare .)
    PRINT           reduce using rule 13 (stmtelt -> declare .)
    RETURN          reduce using rule 13 (stmtelt -> declare .)
    CONTINUE        reduce using rule 13 (stmtelt -> declare .)
    BREAK           reduce using rule 13 (stmtelt -> declare .)
    FLOAT           reduce using rule 13 (stmtelt -> declare .)
    INT             reduce using rule 13 (stmtelt -> declare .)
    CHAR            reduce using rule 13 (stmtelt -> declare .)


state 141

    (14) stmtelt -> assign .

    RFB             reduce using rule 14 (stmtelt -> assign .)
    IDENTIFIER      reduce using rule 14 (stmtelt -> assign .)
    IF              reduce using rule 14 (stmtelt -> assign .)
    WHILE           reduce using rule 14 (stmtelt -> assign .)
    PRINT           reduce using rule 14 (stmtelt -> assign .)
    RETURN          reduce using rule 14 (stmtelt -> assign .)
    CONTINUE        reduce using rule 14 (stmtelt -> assign .)
    BREAK           reduce using rule 14 (stmtelt -> assign .)
    FLOAT           reduce using rule 14 (stmtelt -> assign .)
    INT             reduce using rule 14 (stmtelt -> assign .)
    CHAR            reduce using rule 14 (stmtelt -> assign .)


state 142

    (15) stmtelt -> ifstmt .

    RFB             reduce using rule 15 (stmtelt -> ifstmt .)
    IDENTIFIER      reduce using rule 15 (stmtelt -> ifstmt .)
    IF              reduce using rule 15 (stmtelt -> ifstmt .)
    WHILE           reduce using rule 15 (stmtelt -> ifstmt .)
    PRINT           reduce using rule 15 (stmtelt -> ifstmt .)
    RETURN          reduce using rule 15 (stmtelt -> ifstmt .)
    CONTINUE        reduce using rule 15 (stmtelt -> ifstmt .)
    BREAK           reduce using rule 15 (stmtelt -> ifstmt .)
    FLOAT           reduce using rule 15 (stmtelt -> ifstmt .)
    INT             reduce using rule 15 (stmtelt -> ifstmt .)
    CHAR            reduce using rule 15 (stmtelt -> ifstmt .)


state 143

    (16) stmtelt -> whilestmt .

    RFB             reduce using rule 16 (stmtelt -> whilestmt .)
    IDENTIFIER      reduce using rule 16 (stmtelt -> whilestmt .)
    IF              reduce using rule 16 (stmtelt -> whilestmt .)
    WHILE           reduce using rule 16 (stmtelt -> whilestmt .)
    PRINT           reduce using rule 16 (stmtelt -> whilestmt .)
    RETURN          reduce using rule 16 (stmtelt -> whilestmt .)
    CONTINUE        reduce using rule 16 (stmtelt -> whilestmt .)
    BREAK           reduce using rule 16 (stmtelt -> whilestmt .)
    FLOAT           reduce using rule 16 (stmtelt -> whilestmt .)
    INT             reduce using rule 16 (stmtelt -> whilestmt .)
    CHAR            reduce using rule 16 (stmtelt -> whilestmt .)


state 144

    (17) stmtelt -> printstmt .

    RFB             reduce using rule 17 (stmtelt -> printstmt .)
    IDENTIFIER      reduce using rule 17 (stmtelt -> printstmt .)
    IF              reduce using rule 17 (stmtelt -> printstmt .)
    WHILE           reduce using rule 17 (stmtelt -> printstmt .)
    PRINT           reduce using rule 17 (stmtelt -> printstmt .)
    RETURN          reduce using rule 17 (stmtelt -> printstmt .)
    CONTINUE        reduce using rule 17 (stmtelt -> printstmt .)
    BREAK           reduce using rule 17 (stmtelt -> printstmt .)
    FLOAT           reduce using rule 17 (stmtelt -> printstmt .)
    INT             reduce using rule 17 (stmtelt -> printstmt .)
    CHAR            reduce using rule 17 (stmtelt -> printstmt .)


state 145

    (18) stmtelt -> returnstmt .

    RFB             reduce using rule 18 (stmtelt -> returnstmt .)
    IDENTIFIER      reduce using rule 18 (stmtelt -> returnstmt .)
    IF              reduce using rule 18 (stmtelt -> returnstmt .)
    WHILE           reduce using rule 18 (stmtelt -> returnstmt .)
    PRINT           reduce using rule 18 (stmtelt -> returnstmt .)
    RETURN          reduce using rule 18 (stmtelt -> returnstmt .)
    CONTINUE        reduce using rule 18 (stmtelt -> returnstmt .)
    BREAK           reduce using rule 18 (stmtelt -> returnstmt .)
    FLOAT           reduce using rule 18 (stmtelt -> returnstmt .)
    INT             reduce using rule 18 (stmtelt -> returnstmt .)
    CHAR            reduce using rule 18 (stmtelt -> returnstmt .)


state 146

    (19) stmtelt -> continuestmt .

    RFB             reduce using rule 19 (stmtelt -> continuestmt .)
    IDENTIFIER      reduce using rule 19 (stmtelt -> continuestmt .)
    IF              reduce using rule 19 (stmtelt -> continuestmt .)
    WHILE           reduce using rule 19 (stmtelt -> continuestmt .)
    PRINT           reduce using rule 19 (stmtelt -> continuestmt .)
    RETURN          reduce using rule 19 (stmtelt -> continuestmt .)
    CONTINUE        reduce using rule 19 (stmtelt -> continuestmt .)
    BREAK           reduce using rule 19 (stmtelt -> continuestmt .)
    FLOAT           reduce using rule 19 (stmtelt -> continuestmt .)
    INT             reduce using rule 19 (stmtelt -> continuestmt .)
    CHAR            reduce using rule 19 (stmtelt -> continuestmt .)


state 147

    (20) stmtelt -> breakstmt .

    RFB             reduce using rule 20 (stmtelt -> breakstmt .)
    IDENTIFIER      reduce using rule 20 (stmtelt -> breakstmt .)
    IF              reduce using rule 20 (stmtelt -> breakstmt .)
    WHILE           reduce using rule 20 (stmtelt -> breakstmt .)
    PRINT           reduce using rule 20 (stmtelt -> breakstmt .)
    RETURN          reduce using rule 20 (stmtelt -> breakstmt .)
    CONTINUE        reduce using rule 20 (stmtelt -> breakstmt .)
    BREAK           reduce using rule 20 (stmtelt -> breakstmt .)
    FLOAT           reduce using rule 20 (stmtelt -> breakstmt .)
    INT             reduce using rule 20 (stmtelt -> breakstmt .)
    CHAR            reduce using rule 20 (stmtelt -> breakstmt .)


state 148

    (84) returnstmt -> RETURN . returnelt SEMICOLON
    (85) returnelt -> . expr
    (86) returnelt -> .
    (31) expr -> . expr OR andterm
    (32) expr -> . andterm
    (33) andterm -> . andterm AND equalterm
    (34) andterm -> . equalterm
    (35) equalterm -> . equalterm LOG relopterm
    (36) equalterm -> . relopterm
    (37) relopterm -> . relopterm RELOP arithterm
    (38) relopterm -> . arithterm
    (39) arithterm -> . arithterm ARITHOP multerm
    (40) arithterm -> . multerm
    (41) multerm -> . multerm MULTOP singleterm
    (42) multerm -> . singleterm
    (43) singleterm -> . IDENTIFIER
    (44) singleterm -> . prefix INTNUM
    (45) singleterm -> . prefix FLOATNUM
    (46) singleterm -> . CHARACTER
    (47) singleterm -> . LCB expr RCB
    (48) singleterm -> . arrayid
    (49) prefix -> . ARITHOP
    (50) prefix -> .
    (99) arrayid -> . arrayid1
    (100) arrayid1 -> . arrayid1 LSB index RSB
    (101) arrayid1 -> . IDENTIFIER LSB index RSB

    SEMICOLON       reduce using rule 86 (returnelt -> .)
    IDENTIFIER      shift and go to state 70
    CHARACTER       shift and go to state 67
    LCB             shift and go to state 58
    ARITHOP         shift and go to state 49
    INTNUM          reduce using rule 50 (prefix -> .)
    FLOATNUM        reduce using rule 50 (prefix -> .)

    returnelt                      shift and go to state 155
    expr                           shift and go to state 156
    andterm                        shift and go to state 59
    equalterm                      shift and go to state 61
    relopterm                      shift and go to state 62
    arithterm                      shift and go to state 63
    multerm                        shift and go to state 64
    singleterm                     shift and go to state 65
    prefix                         shift and go to state 66
    arrayid                        shift and go to state 68
    arrayid1                       shift and go to state 21

state 149

    (88) continuestmt -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 157


state 150

    (87) breakstmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 158


state 151

    (75) whilestmt -> WHILE LCB expr RCB LFB whilebegin stmt2 RFB . whileend
    (77) whileend -> .

    FUNCTION        reduce using rule 77 (whileend -> .)
    IDENTIFIER      reduce using rule 77 (whileend -> .)
    IF              reduce using rule 77 (whileend -> .)
    WHILE           reduce using rule 77 (whileend -> .)
    PRINT           reduce using rule 77 (whileend -> .)
    FLOAT           reduce using rule 77 (whileend -> .)
    INT             reduce using rule 77 (whileend -> .)
    CHAR            reduce using rule 77 (whileend -> .)
    $end            reduce using rule 77 (whileend -> .)
    RFB             reduce using rule 77 (whileend -> .)
    RETURN          reduce using rule 77 (whileend -> .)
    CONTINUE        reduce using rule 77 (whileend -> .)
    BREAK           reduce using rule 77 (whileend -> .)

    whileend                       shift and go to state 159

state 152

    (21) funcdef -> FUNCTION type IDENTIFIER funcdefy LCB nulltypeargsx RCB LFB stmt2 . RFB fundefexit
    (10) stmt2 -> stmt2 . stmtelt
    (12) stmtelt -> . funccall SEMICOLON
    (13) stmtelt -> . declare
    (14) stmtelt -> . assign
    (15) stmtelt -> . ifstmt
    (16) stmtelt -> . whilestmt
    (17) stmtelt -> . printstmt
    (18) stmtelt -> . returnstmt
    (19) stmtelt -> . continuestmt
    (20) stmtelt -> . breakstmt
    (58) funccall -> . IDENTIFIER LCB nullargs RCB
    (89) declare -> . type vars SEMICOLON
    (51) assign -> . lhs ASSIGN rhs SEMICOLON
    (68) ifstmt -> . IF LCB expr RCB LFB ifbegin stmt2 RFB ifend elsepart
    (75) whilestmt -> . WHILE LCB expr RCB LFB whilebegin stmt2 RFB whileend
    (78) printstmt -> . PRINT LCB printables RCB SEMICOLON
    (84) returnstmt -> . RETURN returnelt SEMICOLON
    (88) continuestmt -> . CONTINUE SEMICOLON
    (87) breakstmt -> . BREAK SEMICOLON
    (90) type -> . FLOAT
    (91) type -> . INT
    (92) type -> . CHAR
    (52) lhs -> . IDENTIFIER
    (53) lhs -> . arrayid
    (99) arrayid -> . arrayid1
    (100) arrayid1 -> . arrayid1 LSB index RSB
    (101) arrayid1 -> . IDENTIFIER LSB index RSB

    RFB             shift and go to state 160
    IDENTIFIER      shift and go to state 12
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    PRINT           shift and go to state 16
    RETURN          shift and go to state 148
    CONTINUE        shift and go to state 149
    BREAK           shift and go to state 150
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    CHAR            shift and go to state 19

    type                           shift and go to state 11
    stmtelt                        shift and go to state 138
    funccall                       shift and go to state 139
    declare                        shift and go to state 140
    assign                         shift and go to state 141
    ifstmt                         shift and go to state 142
    whilestmt                      shift and go to state 143
    printstmt                      shift and go to state 144
    returnstmt                     shift and go to state 145
    continuestmt                   shift and go to state 146
    breakstmt                      shift and go to state 147
    lhs                            shift and go to state 13
    arrayid                        shift and go to state 20
    arrayid1                       shift and go to state 21

state 153

    (68) ifstmt -> IF LCB expr RCB LFB ifbegin stmt2 RFB ifend . elsepart
    (71) elsepart -> . ELSE LFB elsebegin stmt2 RFB elseend
    (74) elsepart -> .

    ELSE            shift and go to state 162
    FUNCTION        reduce using rule 74 (elsepart -> .)
    IDENTIFIER      reduce using rule 74 (elsepart -> .)
    IF              reduce using rule 74 (elsepart -> .)
    WHILE           reduce using rule 74 (elsepart -> .)
    PRINT           reduce using rule 74 (elsepart -> .)
    FLOAT           reduce using rule 74 (elsepart -> .)
    INT             reduce using rule 74 (elsepart -> .)
    CHAR            reduce using rule 74 (elsepart -> .)
    $end            reduce using rule 74 (elsepart -> .)
    RFB             reduce using rule 74 (elsepart -> .)
    RETURN          reduce using rule 74 (elsepart -> .)
    CONTINUE        reduce using rule 74 (elsepart -> .)
    BREAK           reduce using rule 74 (elsepart -> .)

    elsepart                       shift and go to state 161

state 154

    (12) stmtelt -> funccall SEMICOLON .

    RFB             reduce using rule 12 (stmtelt -> funccall SEMICOLON .)
    IDENTIFIER      reduce using rule 12 (stmtelt -> funccall SEMICOLON .)
    IF              reduce using rule 12 (stmtelt -> funccall SEMICOLON .)
    WHILE           reduce using rule 12 (stmtelt -> funccall SEMICOLON .)
    PRINT           reduce using rule 12 (stmtelt -> funccall SEMICOLON .)
    RETURN          reduce using rule 12 (stmtelt -> funccall SEMICOLON .)
    CONTINUE        reduce using rule 12 (stmtelt -> funccall SEMICOLON .)
    BREAK           reduce using rule 12 (stmtelt -> funccall SEMICOLON .)
    FLOAT           reduce using rule 12 (stmtelt -> funccall SEMICOLON .)
    INT             reduce using rule 12 (stmtelt -> funccall SEMICOLON .)
    CHAR            reduce using rule 12 (stmtelt -> funccall SEMICOLON .)


state 155

    (84) returnstmt -> RETURN returnelt . SEMICOLON

    SEMICOLON       shift and go to state 163


state 156

    (85) returnelt -> expr .
    (31) expr -> expr . OR andterm

    SEMICOLON       reduce using rule 85 (returnelt -> expr .)
    OR              shift and go to state 91


state 157

    (88) continuestmt -> CONTINUE SEMICOLON .

    RFB             reduce using rule 88 (continuestmt -> CONTINUE SEMICOLON .)
    IDENTIFIER      reduce using rule 88 (continuestmt -> CONTINUE SEMICOLON .)
    IF              reduce using rule 88 (continuestmt -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 88 (continuestmt -> CONTINUE SEMICOLON .)
    PRINT           reduce using rule 88 (continuestmt -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 88 (continuestmt -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 88 (continuestmt -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 88 (continuestmt -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 88 (continuestmt -> CONTINUE SEMICOLON .)
    INT             reduce using rule 88 (continuestmt -> CONTINUE SEMICOLON .)
    CHAR            reduce using rule 88 (continuestmt -> CONTINUE SEMICOLON .)


state 158

    (87) breakstmt -> BREAK SEMICOLON .

    RFB             reduce using rule 87 (breakstmt -> BREAK SEMICOLON .)
    IDENTIFIER      reduce using rule 87 (breakstmt -> BREAK SEMICOLON .)
    IF              reduce using rule 87 (breakstmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 87 (breakstmt -> BREAK SEMICOLON .)
    PRINT           reduce using rule 87 (breakstmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 87 (breakstmt -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 87 (breakstmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 87 (breakstmt -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 87 (breakstmt -> BREAK SEMICOLON .)
    INT             reduce using rule 87 (breakstmt -> BREAK SEMICOLON .)
    CHAR            reduce using rule 87 (breakstmt -> BREAK SEMICOLON .)


state 159

    (75) whilestmt -> WHILE LCB expr RCB LFB whilebegin stmt2 RFB whileend .

    FUNCTION        reduce using rule 75 (whilestmt -> WHILE LCB expr RCB LFB whilebegin stmt2 RFB whileend .)
    IDENTIFIER      reduce using rule 75 (whilestmt -> WHILE LCB expr RCB LFB whilebegin stmt2 RFB whileend .)
    IF              reduce using rule 75 (whilestmt -> WHILE LCB expr RCB LFB whilebegin stmt2 RFB whileend .)
    WHILE           reduce using rule 75 (whilestmt -> WHILE LCB expr RCB LFB whilebegin stmt2 RFB whileend .)
    PRINT           reduce using rule 75 (whilestmt -> WHILE LCB expr RCB LFB whilebegin stmt2 RFB whileend .)
    FLOAT           reduce using rule 75 (whilestmt -> WHILE LCB expr RCB LFB whilebegin stmt2 RFB whileend .)
    INT             reduce using rule 75 (whilestmt -> WHILE LCB expr RCB LFB whilebegin stmt2 RFB whileend .)
    CHAR            reduce using rule 75 (whilestmt -> WHILE LCB expr RCB LFB whilebegin stmt2 RFB whileend .)
    $end            reduce using rule 75 (whilestmt -> WHILE LCB expr RCB LFB whilebegin stmt2 RFB whileend .)
    RFB             reduce using rule 75 (whilestmt -> WHILE LCB expr RCB LFB whilebegin stmt2 RFB whileend .)
    RETURN          reduce using rule 75 (whilestmt -> WHILE LCB expr RCB LFB whilebegin stmt2 RFB whileend .)
    CONTINUE        reduce using rule 75 (whilestmt -> WHILE LCB expr RCB LFB whilebegin stmt2 RFB whileend .)
    BREAK           reduce using rule 75 (whilestmt -> WHILE LCB expr RCB LFB whilebegin stmt2 RFB whileend .)


state 160

    (21) funcdef -> FUNCTION type IDENTIFIER funcdefy LCB nulltypeargsx RCB LFB stmt2 RFB . fundefexit
    (23) fundefexit -> .

    FUNCTION        reduce using rule 23 (fundefexit -> .)
    IDENTIFIER      reduce using rule 23 (fundefexit -> .)
    IF              reduce using rule 23 (fundefexit -> .)
    WHILE           reduce using rule 23 (fundefexit -> .)
    PRINT           reduce using rule 23 (fundefexit -> .)
    FLOAT           reduce using rule 23 (fundefexit -> .)
    INT             reduce using rule 23 (fundefexit -> .)
    CHAR            reduce using rule 23 (fundefexit -> .)
    $end            reduce using rule 23 (fundefexit -> .)

    fundefexit                     shift and go to state 164

state 161

    (68) ifstmt -> IF LCB expr RCB LFB ifbegin stmt2 RFB ifend elsepart .

    FUNCTION        reduce using rule 68 (ifstmt -> IF LCB expr RCB LFB ifbegin stmt2 RFB ifend elsepart .)
    IDENTIFIER      reduce using rule 68 (ifstmt -> IF LCB expr RCB LFB ifbegin stmt2 RFB ifend elsepart .)
    IF              reduce using rule 68 (ifstmt -> IF LCB expr RCB LFB ifbegin stmt2 RFB ifend elsepart .)
    WHILE           reduce using rule 68 (ifstmt -> IF LCB expr RCB LFB ifbegin stmt2 RFB ifend elsepart .)
    PRINT           reduce using rule 68 (ifstmt -> IF LCB expr RCB LFB ifbegin stmt2 RFB ifend elsepart .)
    FLOAT           reduce using rule 68 (ifstmt -> IF LCB expr RCB LFB ifbegin stmt2 RFB ifend elsepart .)
    INT             reduce using rule 68 (ifstmt -> IF LCB expr RCB LFB ifbegin stmt2 RFB ifend elsepart .)
    CHAR            reduce using rule 68 (ifstmt -> IF LCB expr RCB LFB ifbegin stmt2 RFB ifend elsepart .)
    $end            reduce using rule 68 (ifstmt -> IF LCB expr RCB LFB ifbegin stmt2 RFB ifend elsepart .)
    RFB             reduce using rule 68 (ifstmt -> IF LCB expr RCB LFB ifbegin stmt2 RFB ifend elsepart .)
    RETURN          reduce using rule 68 (ifstmt -> IF LCB expr RCB LFB ifbegin stmt2 RFB ifend elsepart .)
    CONTINUE        reduce using rule 68 (ifstmt -> IF LCB expr RCB LFB ifbegin stmt2 RFB ifend elsepart .)
    BREAK           reduce using rule 68 (ifstmt -> IF LCB expr RCB LFB ifbegin stmt2 RFB ifend elsepart .)


state 162

    (71) elsepart -> ELSE . LFB elsebegin stmt2 RFB elseend

    LFB             shift and go to state 165


state 163

    (84) returnstmt -> RETURN returnelt SEMICOLON .

    RFB             reduce using rule 84 (returnstmt -> RETURN returnelt SEMICOLON .)
    IDENTIFIER      reduce using rule 84 (returnstmt -> RETURN returnelt SEMICOLON .)
    IF              reduce using rule 84 (returnstmt -> RETURN returnelt SEMICOLON .)
    WHILE           reduce using rule 84 (returnstmt -> RETURN returnelt SEMICOLON .)
    PRINT           reduce using rule 84 (returnstmt -> RETURN returnelt SEMICOLON .)
    RETURN          reduce using rule 84 (returnstmt -> RETURN returnelt SEMICOLON .)
    CONTINUE        reduce using rule 84 (returnstmt -> RETURN returnelt SEMICOLON .)
    BREAK           reduce using rule 84 (returnstmt -> RETURN returnelt SEMICOLON .)
    FLOAT           reduce using rule 84 (returnstmt -> RETURN returnelt SEMICOLON .)
    INT             reduce using rule 84 (returnstmt -> RETURN returnelt SEMICOLON .)
    CHAR            reduce using rule 84 (returnstmt -> RETURN returnelt SEMICOLON .)


state 164

    (21) funcdef -> FUNCTION type IDENTIFIER funcdefy LCB nulltypeargsx RCB LFB stmt2 RFB fundefexit .

    FUNCTION        reduce using rule 21 (funcdef -> FUNCTION type IDENTIFIER funcdefy LCB nulltypeargsx RCB LFB stmt2 RFB fundefexit .)
    IDENTIFIER      reduce using rule 21 (funcdef -> FUNCTION type IDENTIFIER funcdefy LCB nulltypeargsx RCB LFB stmt2 RFB fundefexit .)
    IF              reduce using rule 21 (funcdef -> FUNCTION type IDENTIFIER funcdefy LCB nulltypeargsx RCB LFB stmt2 RFB fundefexit .)
    WHILE           reduce using rule 21 (funcdef -> FUNCTION type IDENTIFIER funcdefy LCB nulltypeargsx RCB LFB stmt2 RFB fundefexit .)
    PRINT           reduce using rule 21 (funcdef -> FUNCTION type IDENTIFIER funcdefy LCB nulltypeargsx RCB LFB stmt2 RFB fundefexit .)
    FLOAT           reduce using rule 21 (funcdef -> FUNCTION type IDENTIFIER funcdefy LCB nulltypeargsx RCB LFB stmt2 RFB fundefexit .)
    INT             reduce using rule 21 (funcdef -> FUNCTION type IDENTIFIER funcdefy LCB nulltypeargsx RCB LFB stmt2 RFB fundefexit .)
    CHAR            reduce using rule 21 (funcdef -> FUNCTION type IDENTIFIER funcdefy LCB nulltypeargsx RCB LFB stmt2 RFB fundefexit .)
    $end            reduce using rule 21 (funcdef -> FUNCTION type IDENTIFIER funcdefy LCB nulltypeargsx RCB LFB stmt2 RFB fundefexit .)


state 165

    (71) elsepart -> ELSE LFB . elsebegin stmt2 RFB elseend
    (72) elsebegin -> .

    RFB             reduce using rule 72 (elsebegin -> .)
    IDENTIFIER      reduce using rule 72 (elsebegin -> .)
    IF              reduce using rule 72 (elsebegin -> .)
    WHILE           reduce using rule 72 (elsebegin -> .)
    PRINT           reduce using rule 72 (elsebegin -> .)
    RETURN          reduce using rule 72 (elsebegin -> .)
    CONTINUE        reduce using rule 72 (elsebegin -> .)
    BREAK           reduce using rule 72 (elsebegin -> .)
    FLOAT           reduce using rule 72 (elsebegin -> .)
    INT             reduce using rule 72 (elsebegin -> .)
    CHAR            reduce using rule 72 (elsebegin -> .)

    elsebegin                      shift and go to state 166

state 166

    (71) elsepart -> ELSE LFB elsebegin . stmt2 RFB elseend
    (10) stmt2 -> . stmt2 stmtelt
    (11) stmt2 -> .

    RFB             reduce using rule 11 (stmt2 -> .)
    IDENTIFIER      reduce using rule 11 (stmt2 -> .)
    IF              reduce using rule 11 (stmt2 -> .)
    WHILE           reduce using rule 11 (stmt2 -> .)
    PRINT           reduce using rule 11 (stmt2 -> .)
    RETURN          reduce using rule 11 (stmt2 -> .)
    CONTINUE        reduce using rule 11 (stmt2 -> .)
    BREAK           reduce using rule 11 (stmt2 -> .)
    FLOAT           reduce using rule 11 (stmt2 -> .)
    INT             reduce using rule 11 (stmt2 -> .)
    CHAR            reduce using rule 11 (stmt2 -> .)

    stmt2                          shift and go to state 167

state 167

    (71) elsepart -> ELSE LFB elsebegin stmt2 . RFB elseend
    (10) stmt2 -> stmt2 . stmtelt
    (12) stmtelt -> . funccall SEMICOLON
    (13) stmtelt -> . declare
    (14) stmtelt -> . assign
    (15) stmtelt -> . ifstmt
    (16) stmtelt -> . whilestmt
    (17) stmtelt -> . printstmt
    (18) stmtelt -> . returnstmt
    (19) stmtelt -> . continuestmt
    (20) stmtelt -> . breakstmt
    (58) funccall -> . IDENTIFIER LCB nullargs RCB
    (89) declare -> . type vars SEMICOLON
    (51) assign -> . lhs ASSIGN rhs SEMICOLON
    (68) ifstmt -> . IF LCB expr RCB LFB ifbegin stmt2 RFB ifend elsepart
    (75) whilestmt -> . WHILE LCB expr RCB LFB whilebegin stmt2 RFB whileend
    (78) printstmt -> . PRINT LCB printables RCB SEMICOLON
    (84) returnstmt -> . RETURN returnelt SEMICOLON
    (88) continuestmt -> . CONTINUE SEMICOLON
    (87) breakstmt -> . BREAK SEMICOLON
    (90) type -> . FLOAT
    (91) type -> . INT
    (92) type -> . CHAR
    (52) lhs -> . IDENTIFIER
    (53) lhs -> . arrayid
    (99) arrayid -> . arrayid1
    (100) arrayid1 -> . arrayid1 LSB index RSB
    (101) arrayid1 -> . IDENTIFIER LSB index RSB

    RFB             shift and go to state 168
    IDENTIFIER      shift and go to state 12
    IF              shift and go to state 14
    WHILE           shift and go to state 15
    PRINT           shift and go to state 16
    RETURN          shift and go to state 148
    CONTINUE        shift and go to state 149
    BREAK           shift and go to state 150
    FLOAT           shift and go to state 17
    INT             shift and go to state 18
    CHAR            shift and go to state 19

    stmtelt                        shift and go to state 138
    funccall                       shift and go to state 139
    declare                        shift and go to state 140
    assign                         shift and go to state 141
    ifstmt                         shift and go to state 142
    whilestmt                      shift and go to state 143
    printstmt                      shift and go to state 144
    returnstmt                     shift and go to state 145
    continuestmt                   shift and go to state 146
    breakstmt                      shift and go to state 147
    type                           shift and go to state 11
    lhs                            shift and go to state 13
    arrayid                        shift and go to state 20
    arrayid1                       shift and go to state 21

state 168

    (71) elsepart -> ELSE LFB elsebegin stmt2 RFB . elseend
    (73) elseend -> .

    FUNCTION        reduce using rule 73 (elseend -> .)
    IDENTIFIER      reduce using rule 73 (elseend -> .)
    IF              reduce using rule 73 (elseend -> .)
    WHILE           reduce using rule 73 (elseend -> .)
    PRINT           reduce using rule 73 (elseend -> .)
    FLOAT           reduce using rule 73 (elseend -> .)
    INT             reduce using rule 73 (elseend -> .)
    CHAR            reduce using rule 73 (elseend -> .)
    $end            reduce using rule 73 (elseend -> .)
    RFB             reduce using rule 73 (elseend -> .)
    RETURN          reduce using rule 73 (elseend -> .)
    CONTINUE        reduce using rule 73 (elseend -> .)
    BREAK           reduce using rule 73 (elseend -> .)

    elseend                        shift and go to state 169

state 169

    (71) elsepart -> ELSE LFB elsebegin stmt2 RFB elseend .

    FUNCTION        reduce using rule 71 (elsepart -> ELSE LFB elsebegin stmt2 RFB elseend .)
    IDENTIFIER      reduce using rule 71 (elsepart -> ELSE LFB elsebegin stmt2 RFB elseend .)
    IF              reduce using rule 71 (elsepart -> ELSE LFB elsebegin stmt2 RFB elseend .)
    WHILE           reduce using rule 71 (elsepart -> ELSE LFB elsebegin stmt2 RFB elseend .)
    PRINT           reduce using rule 71 (elsepart -> ELSE LFB elsebegin stmt2 RFB elseend .)
    FLOAT           reduce using rule 71 (elsepart -> ELSE LFB elsebegin stmt2 RFB elseend .)
    INT             reduce using rule 71 (elsepart -> ELSE LFB elsebegin stmt2 RFB elseend .)
    CHAR            reduce using rule 71 (elsepart -> ELSE LFB elsebegin stmt2 RFB elseend .)
    $end            reduce using rule 71 (elsepart -> ELSE LFB elsebegin stmt2 RFB elseend .)
    RFB             reduce using rule 71 (elsepart -> ELSE LFB elsebegin stmt2 RFB elseend .)
    RETURN          reduce using rule 71 (elsepart -> ELSE LFB elsebegin stmt2 RFB elseend .)
    CONTINUE        reduce using rule 71 (elsepart -> ELSE LFB elsebegin stmt2 RFB elseend .)
    BREAK           reduce using rule 71 (elsepart -> ELSE LFB elsebegin stmt2 RFB elseend .)

